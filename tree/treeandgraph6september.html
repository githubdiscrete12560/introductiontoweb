<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph Theory & Tree Algorithms | ทฤษฎีกราฟและอัลกอริทึมต้นไม้</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;600&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Warm Neutrals -->
    <!-- Application Structure Plan: The application uses a two-column layout with a fixed sidebar for navigation and a main content panel. This structure was chosen to facilitate non-linear learning, allowing users to easily jump between fundamental concepts and interactive algorithm visualizations. The core of the user experience is the interactive canvas-based simulators for Tree Traversals and MST algorithms, which transform passive reading into an active, exploratory process. Users select a topic, view the content, and engage with the visualizers to build a deeper understanding. -->
    <!-- Visualization & Content Choices: 
        - Report Info: Basic definitions (Graph, Tree, Path, Cycle). Goal: Inform. Viz/Method: Structured HTML/CSS text and simple diagrams. Interaction: None. Justification: These are foundational concepts best served by clear, concise text.
        - Report Info: Tree Traversals (In-order, Pre-order, Post-order). Goal: Demonstrate Process. Viz/Method: Interactive HTML Canvas visualization. Interaction: Users click buttons to trigger a step-by-step animation of the selected traversal on a binary tree, with the output sequence built dynamically. Justification: A visual animation is far more intuitive for understanding the recursive path of traversals than static pseudocode. Library/Method: HTML Canvas API.
        - Report Info: MST Algorithms (Prim's, Kruskal's). Goal: Demonstrate & Compare Algorithms. Viz/Method: Interactive HTML Canvas visualization of a weighted graph. Interaction: Users can run each algorithm. The animation shows edges/nodes being considered and added to the MST, with the total weight updated in real-time. Justification: Visualizing the step-by-step decision-making process of these greedy algorithms makes their logic clear and easy to follow. Library/Method: HTML Canvas API.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', 'Sarabun', sans-serif;
        }
        .thai {
            font-family: 'Sarabun', sans-serif;
        }
        .nav-link.active {
            background-color: #D1C4E9;
            color: #311B92;
            font-weight: 600;
        }
        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
        }
        .code-block {
            background-color: #F3F4F6;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: monospace;
            white-space: pre;
        }
    </style>
</head>
<body class="bg-[#F5F3F1] text-gray-800">
    <div class="flex flex-col md:flex-row min-h-screen">
        <aside class="w-full md:w-64 bg-[#EDEBE9] p-4 md:p-6 shadow-lg flex-shrink-0">
            <h1 class="text-xl font-bold text-[#4A4441] mb-2">Graph Theory Explorer</h1>
            <h2 class="text-lg font-semibold text-[#6F6864] thai mb-6">สำรวจทฤษฎีกราฟ</h2>
            <nav id="navigation" class="space-y-2">
                <a href="#intro" class="nav-link block p-3 rounded-lg hover:bg-gray-200 transition-colors duration-200">
                    Graph vs. Tree <br><span class="thai text-sm">กราฟ กับ ต้นไม้</span>
                </a>
                <a href="#paths" class="nav-link block p-3 rounded-lg hover:bg-gray-200 transition-colors duration-200">
                    Paths & Cycles <br><span class="thai text-sm">วิถีและวัฏจักร</span>
                </a>
                <a href="#binary-tree" class="nav-link block p-3 rounded-lg hover:bg-gray-200 transition-colors duration-200">
                    Binary Trees <br><span class="thai text-sm">ต้นไม้แบบทวิภาค</span>
                </a>
                <a href="#traversals" class="nav-link block p-3 rounded-lg hover:bg-gray-200 transition-colors duration-200">
                    Tree Traversals <br><span class="thai text-sm">การท่องไปในต้นไม้</span>
                </a>
                <a href="#spanning-tree" class="nav-link block p-3 rounded-lg hover:bg-gray-200 transition-colors duration-200">
                    Spanning Trees <br><span class="thai text-sm">ต้นไม้แบบทอดข้าม</span>
                </a>
                 <a href="#mst" class="nav-link block p-3 rounded-lg hover:bg-gray-200 transition-colors duration-200">
                    MST Algorithms <br><span class="thai text-sm">อัลกอริทึม MST</span>
                </a>
            </nav>
        </aside>

        <main class="flex-1 p-4 md:p-8 overflow-y-auto">
            
            <section id="intro" class="content-section space-y-6">
                <h2 class="text-3xl font-bold text-[#4A4441]">Introduction: Graph vs. Tree <span class="thai">| บทนำ: กราฟ กับ ต้นไม้</span></h2>
                <p class="text-lg text-gray-600">This section introduces the fundamental concepts of graphs and trees, two essential structures in computer science. Understanding their differences is the first step in mastering graph theory. <span class="thai">ส่วนนี้จะแนะนำแนวคิดพื้นฐานของกราฟและต้นไม้ ซึ่งเป็นโครงสร้างที่สำคัญสองอย่างในวิทยาการคอมพิวเตอร์ การเข้าใจความแตกต่างของทั้งสองเป็นขั้นตอนแรกในการเรียนรู้ทฤษฎีกราฟ</span></p>

                <div class="grid md:grid-cols-2 gap-6">
                    <div class="bg-white p-6 rounded-xl shadow-md">
                        <h3 class="text-2xl font-semibold mb-3">What is a Graph? <span class="thai">| กราฟคืออะไร?</span></h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-700">
                            <li>A collection of nodes (vertices) connected by edges.<br><span class="thai ml-4">กลุ่มของโหนด (จุดยอด) ที่เชื่อมต่อกันด้วยเส้นเชื่อม (Edges)</span></li>
                            <li>Can represent many real-world systems: social networks, road maps, computer networks.<br><span class="thai ml-4">สามารถใช้แทนระบบในโลกแห่งความเป็นจริงได้มากมาย เช่น เครือข่ายสังคม, แผนที่ถนน, เครือข่ายคอมพิวเตอร์</span></li>
                            <li>Graphs can contain cycles (paths that start and end at the same node).<br><span class="thai ml-4">กราฟสามารถมีวัฏจักร (Cycle) ได้ (เส้นทางที่เริ่มต้นและสิ้นสุดที่โหนดเดียวกัน)</span></li>
                        </ul>
                    </div>
                    <div class="bg-white p-6 rounded-xl shadow-md">
                        <h3 class="text-2xl font-semibold mb-3">What is a Tree? <span class="thai">| ต้นไม้คืออะไร?</span></h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-700">
                            <li>A special type of connected graph that has <strong>no cycles</strong>.<br><span class="thai ml-4">กราฟเชื่อมต่อชนิดพิเศษที่ <strong>ไม่มีวัฏจักร</strong></span></li>
                            <li>There is only one unique path between any two nodes.<br><span class="thai ml-4">มีเส้นทางเพียงหนึ่งเดียวระหว่างสองโหนดใดๆ</span></li>
                            <li>Think of a family tree or a file system structure.<br><span class="thai ml-4">ลองนึกถึงแผนภูมิต้นไม้ครอบครัวหรือโครงสร้างระบบไฟล์</span></li>
                        </ul>
                    </div>
                </div>
                 <div class="bg-purple-100 border-l-4 border-purple-500 text-purple-700 p-4 rounded-lg" role="alert">
                    <p class="font-bold">Key Relationship | ความสัมพันธ์หลัก</p>
                    <p>Every tree is a graph, but not every graph is a tree. <span class="thai">ต้นไม้ทุกต้นเป็นกราฟ แต่ไม่ใช่ทุกกราฟที่เป็นต้นไม้</span></p>
                </div>
            </section>

            <section id="paths" class="content-section space-y-6">
                <h2 class="text-3xl font-bold text-[#4A4441]">Paths & Cycles <span class="thai">| วิถีและวัฏจักร</span></h2>
                <p class="text-lg text-gray-600">Paths and cycles describe how vertices are connected within a graph. The absence of cycles is the defining characteristic that turns a general graph into a tree. <span class="thai">วิถีและวัฏจักรอธิบายว่าจุดยอดเชื่อมต่อกันภายในกราฟอย่างไร การไม่มีวัฏจักรเป็นลักษณะเฉพาะที่เปลี่ยนกราฟทั่วไปให้กลายเป็นต้นไม้</span></p>
                
                 <div class="grid md:grid-cols-2 gap-6">
                    <div class="bg-white p-6 rounded-xl shadow-md">
                        <h3 class="text-2xl font-semibold mb-3">Paths <span class="thai">| วิถี</span></h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-700">
                            <li>A <strong>path</strong> in a graph is a sequence of vertices where each adjacent pair is connected by an edge.<br><span class="thai ml-4"><strong>วิถี</strong> ในกราฟคือลำดับของจุดยอดที่แต่ละคู่ที่อยู่ติดกันเชื่อมต่อกันด้วยเส้นเชื่อม</span></li>
                            <li>It's like a trail from one vertex to another.<br><span class="thai ml-4">เหมือนกับเส้นทางจากจุดยอดหนึ่งไปยังอีกจุดยอดหนึ่ง</span></li>
                             <li><strong>Simple Path:</strong> A path that does not repeat any vertices.<br><span class="thai ml-4"><strong>วิถีเชิงเดียว (Simple Path):</strong> วิถีที่ไม่ผ่านจุดยอดซ้ำ</span></li>
                        </ul>
                    </div>
                    <div class="bg-white p-6 rounded-xl shadow-md">
                        <h3 class="text-2xl font-semibold mb-3">Cycles <span class="thai">| วัฏจักร</span></h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-700">
                           <li>A <strong>cycle</strong> is a path that starts and ends at the same vertex.<br><span class="thai ml-4"><strong>วัฏจักร</strong> คือวิถีที่เริ่มต้นและสิ้นสุดที่จุดยอดเดียวกัน</span></li>
                            <li><strong>Simple Cycle:</strong> A cycle that does not repeat vertices, except for the start/end vertex.<br><span class="thai ml-4"><strong>วัฏจักรเชิงเดียว (Simple Cycle):</strong> วัฏจักรที่ไม่ผ่านจุดยอดซ้ำ ยกเว้นจุดเริ่มต้น/สิ้นสุด</span></li>
                             <li>Graphs without cycles are called <strong>acyclic</strong>. A connected, acyclic graph is a <strong>tree</strong>!<br><span class="thai ml-4">กราฟที่ไม่มีวัฏจักรเรียกว่า <strong>กราฟอวัฏจักร (Acyclic Graph)</strong> กราฟที่เชื่อมต่อและไม่มีวัฏจักรคือ <strong>ต้นไม้</strong>!</span></li>
                        </ul>
                    </div>
                </div>
            </section>
            
            <section id="binary-tree" class="content-section space-y-6">
                 <h2 class="text-3xl font-bold text-[#4A4441]">Binary Trees <span class="thai">| ต้นไม้แบบทวิภาค</span></h2>
                 <p class="text-lg text-gray-600">Binary trees are a fundamental hierarchical data structure. Each node has at most two children, which introduces powerful ways to store and search for data efficiently. <span class="thai">ต้นไม้แบบทวิภาคเป็นโครงสร้างข้อมูลลำดับชั้นพื้นฐาน แต่ละโหนดมีลูกได้ไม่เกินสองโหนด ซึ่งเป็นวิธีที่มีประสิทธิภาพในการจัดเก็บและค้นหาข้อมูล</span></p>

                <div class="bg-white p-6 rounded-xl shadow-md">
                    <h3 class="text-2xl font-semibold mb-3">What is a Binary Tree? <span class="thai">| ต้นไม้แบบทวิภาคคืออะไร?</span></h3>
                    <ul class="list-disc list-inside space-y-2 text-gray-700">
                        <li>A tree data structure where each node has at most two children, referred to as the <i>left child</i> and the <i>right child</i>.<br><span class="thai ml-4">โครงสร้างข้อมูลแบบต้นไม้ที่แต่ละโหนดมีลูกได้ไม่เกินสองโหนด เรียกว่า <i>ลูกซ้าย (Left Child)</i> และ <i>ลูกขวา (Right Child)</i></span></li>
                        <li>It's a hierarchical structure with a single root node.<br><span class="thai ml-4">เป็นโครงสร้างแบบลำดับชั้นที่มีโหนดราก (Root) เพียงโหนดเดียว</span></li>
                    </ul>

                    <h4 class="text-xl font-semibold mt-6 mb-3">Key Properties: <span class="thai">| คุณสมบัติหลัก:</span></h4>
                     <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                        <div class="bg-gray-100 p-4 rounded-lg"><strong>Root</strong><br><span class="thai">ราก</span><p class="text-sm text-gray-600">The topmost node.</p></div>
                        <div class="bg-gray-100 p-4 rounded-lg"><strong>Parent</strong><br><span class="thai">แม่</span><p class="text-sm text-gray-600">A node with children.</p></div>
                        <div class="bg-gray-100 p-4 rounded-lg"><strong>Child</strong><br><span class="thai">ลูก</span><p class="text-sm text-gray-600">A node extending from a parent.</p></div>
                        <div class="bg-gray-100 p-4 rounded-lg"><strong>Leaf</strong><br><span class="thai">ใบ</span><p class="text-sm text-gray-600">A node with no children.</p></div>
                    </div>
                </div>
            </section>

            <section id="traversals" class="content-section space-y-6">
                <h2 class="text-3xl font-bold text-[#4A4441]">Interactive Tree Traversals <span class="thai">| การท่องไปในต้นไม้แบบโต้ตอบ</span></h2>
                <p class="text-lg text-gray-600">Tree traversal is the process of visiting each node in a tree exactly once. Recursion is a natural fit for this task. Click the buttons below to visualize different traversal methods on the sample tree. <span class="thai">การท่องไปในต้นไม้คือกระบวนการเยี่ยมชมแต่ละโหนดในต้นไม้เพียงครั้งเดียว การเรียกซ้ำเป็นวิธีที่เหมาะสมสำหรับงานนี้ คลิกปุ่มด้านล่างเพื่อดูวิธีการท่องไปในรูปแบบต่างๆ บนต้นไม้ตัวอย่าง</span></p>

                <div class="bg-white p-6 rounded-xl shadow-md">
                    <div class="chart-container relative w-full max-w-lg mx-auto h-80 md:h-96">
                       <canvas id="traversalCanvas"></canvas>
                    </div>
                    <div class="flex justify-center space-x-2 md:space-x-4 my-4 flex-wrap gap-2">
                        <button id="inOrderBtn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">In-order <span class="thai">(ซ้าย, ราก, ขวา)</span></button>
                        <button id="preOrderBtn" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Pre-order <span class="thai">(ราก, ซ้าย, ขวา)</span></button>
                        <button id="postOrderBtn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Post-order <span class="thai">(ซ้าย, ขวา, ราก)</span></button>
                    </div>
                    <div class="text-center">
                        <h3 class="text-xl font-semibold">Traversal Result <span class="thai">| ผลลัพธ์:</span></h3>
                        <p id="traversalResult" class="text-2xl font-mono bg-gray-100 p-3 rounded-lg inline-block mt-2 min-h-[48px]">...</p>
                    </div>
                </div>
            </section>

            <section id="spanning-tree" class="content-section space-y-6">
                <h2 class="text-3xl font-bold text-[#4A4441]">Spanning Trees <span class="thai">| ต้นไม้แบบทอดข้าม</span></h2>
                <p class="text-lg text-gray-600">A spanning tree is a special subgraph that connects all vertices of a larger graph using the minimum possible number of edges, creating a tree structure without any cycles. This concept is crucial for network design and optimization problems. <span class="thai">ต้นไม้แบบทอดข้ามเป็นกราฟย่อยพิเศษที่เชื่อมต่อจุดยอดทั้งหมดของกราฟขนาดใหญ่โดยใช้จำนวนเส้นเชื่อน้อยที่สุดเท่าที่จะเป็นไปได้ ทำให้เกิดโครงสร้างต้นไม้ที่ไม่มีวัฏจักร แนวคิดนี้มีความสำคัญต่อการออกแบบเครือข่ายและปัญหาการปรับให้เหมาะสม</span></p>

                <div class="bg-white p-6 rounded-xl shadow-md">
                     <h3 class="text-2xl font-semibold mb-3">What is a Spanning Tree? <span class="thai">| ต้นไม้แบบทอดข้ามคืออะไร?</span></h3>
                     <ul class="list-disc list-inside space-y-2 text-gray-700">
                         <li>A <strong>spanning tree</strong> of a connected, undirected graph is a subgraph that connects all the vertices together.<br><span class="thai ml-4"><strong>ต้นไม้แบบทอดข้าม</strong> ของกราฟที่ไม่มีทิศทางและเชื่อมต่อกัน คือกราฟย่อยที่เชื่อมต่อจุดยอดทั้งหมดเข้าด้วยกัน</span></li>
                         <li>It is a tree, meaning it has no cycles.<br><span class="thai ml-4">เป็นต้นไม้ ซึ่งหมายความว่าไม่มีวัฏจักร</span></li>
                         <li>It includes every vertex from the original graph.<br><span class="thai ml-4">ประกอบด้วยจุดยอดทุกจุดจากกราฟเดิม</span></li>
                         <li>A single graph can have multiple different spanning trees.<br><span class="thai ml-4">กราฟหนึ่งกราฟสามารถมีต้นไม้แบบทอดข้ามที่แตกต่างกันได้หลายแบบ</span></li>
                     </ul>
                </div>
            </section>

            <section id="mst" class="content-section space-y-6">
                <h2 class="text-3xl font-bold text-[#4A4441]">Minimum Spanning Tree (MST) Algorithms <span class="thai">| อัลกอริทึมต้นไม้แบบทอดข้ามที่น้อยที่สุด</span></h2>
                <p class="text-lg text-gray-600">For a weighted graph, an MST is the spanning tree with the lowest total edge weight. It represents the cheapest way to connect all points in a network. Below, you can visualize two famous greedy algorithms for finding the MST: Prim's and Kruskal's. <span class="thai">สำหรับกราฟถ่วงน้ำหนัก MST คือต้นไม้แบบทอดข้ามที่มีน้ำหนักเส้นเชื่อมรวมน้อยที่สุด ซึ่งแสดงถึงวิธีที่ถูกที่สุดในการเชื่อมต่อทุกจุดในเครือข่าย ด้านล่างนี้ คุณสามารถเห็นภาพอัลกอริทึมเชิงละโมบสองแบบที่มีชื่อเสียงในการค้นหา MST: อัลกอริทึมของพริมและของครูสกัล</span></p>
                
                <div class="bg-white p-6 rounded-xl shadow-md">
                    <div class="chart-container relative w-full max-w-2xl mx-auto h-96 md:h-[500px]">
                       <canvas id="mstCanvas"></canvas>
                    </div>
                    <div class="flex justify-center space-x-2 md:space-x-4 my-4 flex-wrap gap-2">
                        <button id="primsBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Run Prim's Algorithm</button>
                        <button id="kruskalsBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Run Kruskal's Algorithm</button>
                         <button id="resetMstBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Reset</button>
                    </div>
                     <div class="text-center">
                        <h3 class="text-xl font-semibold">Algorithm Steps / Result <span class="thai">| ขั้นตอน / ผลลัพธ์:</span></h3>
                        <p id="mstResult" class="text-lg font-mono bg-gray-100 p-3 rounded-lg mt-2 min-h-[48px]">Ready to start...</p>
                        <p id="mstTotalWeight" class="text-lg font-bold mt-2">Total Weight: 0</p>
                    </div>
                </div>
            </section>

        </main>
    </div>
    <footer class="text-center p-4 text-gray-500 text-sm bg-[#F5F3F1]">
        <p>Created by Google Gemini | Technologies: Tailwind CSS, HTML5 Canvas</p>
        <p class="thai">สร้างโดย Google Gemini | เทคโนโลยี: Tailwind CSS, HTML5 Canvas</p>
    </footer>

<script>
document.addEventListener('DOMContentLoaded', () => {

    const navigationLinks = document.querySelectorAll('.nav-link');
    const contentSections = document.querySelectorAll('.content-section');

    function updateActiveContent() {
        const hash = window.location.hash || '#intro';
        
        navigationLinks.forEach(link => {
            if (link.getAttribute('href') === hash) {
                link.classList.add('active');
            } else {
                link.classList.remove('active');
            }
        });

        contentSections.forEach(section => {
            if ('#' + section.id === hash) {
                section.classList.add('active');
            } else {
                section.classList.remove('active');
            }
        });
        
        if (hash === '#traversals') {
            initTraversalVisualizer();
        }
        if (hash === '#mst') {
            initMstVisualizer();
        }
    }

    navigationLinks.forEach(link => {
        link.addEventListener('click', (e) => {
            setTimeout(() => updateActiveContent(), 0);
        });
    });

    window.addEventListener('hashchange', updateActiveContent);
    updateActiveContent();


    let currentTraversal = { id: null };
    let mstAnimationRunning = false;

    function initTraversalVisualizer() {
        const canvas = document.getElementById('traversalCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const resultEl = document.getElementById('traversalResult');

        const tree = {
            value: 1,
            left: {
                value: 2,
                left: { value: 4, left: null, right: null },
                right: { value: 5, left: null, right: null }
            },
            right: { value: 3, left: null, right: null }
        };

        const nodePositions = new Map();
        
        function setNodePositions(node, x, y, dx) {
            if (!node) return;
            nodePositions.set(node.value, { x, y });
            setNodePositions(node.left, x - dx, y + 80, dx / 2);
            setNodePositions(node.right, x + dx, y + 80, dx / 2);
        }

        function drawNode(node, highlight = false) {
            if (!node) return;
            const pos = nodePositions.get(node.value);

            if (node.left) {
                const leftPos = nodePositions.get(node.left.value);
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(leftPos.x, leftPos.y);
                ctx.strokeStyle = '#9CA3AF';
                ctx.stroke();
            }
            if (node.right) {
                const rightPos = nodePositions.get(node.right.value);
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(rightPos.x, rightPos.y);
                ctx.strokeStyle = '#9CA3AF';
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 20, 0, 2 * Math.PI);
            ctx.fillStyle = highlight ? '#A78BFA' : '#E5E7EB';
            ctx.fill();
            ctx.strokeStyle = highlight ? '#6D28D9' : '#4B5563';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = highlight ? 'white' : '#1F2937';
            ctx.font = '16px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.value, pos.x, pos.y);
        }

        function drawTree() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            setNodePositions(tree, canvas.width / 2, 50, canvas.width / 4);
            
            (function traverseAndDraw(node) {
                if (!node) return;
                traverseAndDraw(node.left);
                traverseAndDraw(node.right);
                drawNode(node);
            })(tree);
        }

        async function animateTraversal(order) {
            const animationId = Symbol();
            currentTraversal.id = animationId;

            resultEl.textContent = '...';
            let result = [];
            
            for (const nodeVal of order) {
                if (currentTraversal.id !== animationId) {
                    return; 
                }

                drawTree(); 
                const nodeToHighlight = findNode(tree, nodeVal);
                
                 (function traverseAndDraw(node, highlightNode) {
                    if (!node) return;
                    traverseAndDraw(node.left, highlightNode);
                    traverseAndDraw(node.right, highlightNode);
                    drawNode(node, node === highlightNode);
                })(tree, nodeToHighlight);

                result.push(nodeVal);
                resultEl.textContent = result.join(', ');
                await new Promise(res => setTimeout(res, 600));
            }
            
            if (currentTraversal.id === animationId) {
                drawTree();
            }
        }

        function findNode(node, value) {
            if (!node) return null;
            if (node.value === value) return node;
            return findNode(node.left, value) || findNode(node.right, value);
        }

        document.getElementById('inOrderBtn').onclick = () => animateTraversal([4, 2, 5, 1, 3]);
        document.getElementById('preOrderBtn').onclick = () => animateTraversal([1, 2, 4, 5, 3]);
        document.getElementById('postOrderBtn').onclick = () => animateTraversal([4, 5, 2, 3, 1]);

        drawTree();
        new ResizeObserver(drawTree).observe(canvas.parentElement);
    }
    
    function initMstVisualizer() {
        const canvas = document.getElementById('mstCanvas');
        if(!canvas) return;
        const ctx = canvas.getContext('2d');
        const resultEl = document.getElementById('mstResult');
        const weightEl = document.getElementById('mstTotalWeight');

        const nodes = [
            { id: 'A', x: 0.2, y: 0.2 }, { id: 'B', x: 0.5, y: 0.1 }, 
            { id: 'C', x: 0.8, y: 0.3 }, { id: 'D', x: 0.75, y: 0.7 },
            { id: 'E', x: 0.4, y: 0.85 }, { id: 'F', x: 0.15, y: 0.6 }
        ];
        const edges = [
            { from: 'A', to: 'B', weight: 7 }, { from: 'A', to: 'F', weight: 3 },
            { from: 'B', to: 'C', weight: 4 }, { from: 'B', to: 'F', weight: 6 },
            { from: 'C', to: 'D', weight: 2 }, { from: 'D', to: 'E', weight: 5 },
            { from: 'D', to: 'F', weight: 8 }, { from: 'E', to: 'F', weight: 9 }
        ];

        let drawnState = { mstEdges: [], highlightedEdge: null, highlightedNodes: new Set() };

        function drawGraph() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const nodeMap = new Map(nodes.map(n => [n.id, { x: n.x * canvas.width, y: n.y * canvas.height }]));

            edges.forEach(edge => {
                const pos1 = nodeMap.get(edge.from);
                const pos2 = nodeMap.get(edge.to);
                const isMstEdge = drawnState.mstEdges.some(e => (e.from === edge.from && e.to === edge.to) || (e.from === edge.to && e.to === edge.from));
                const isHighlighted = drawnState.highlightedEdge === edge;

                ctx.beginPath();
                ctx.moveTo(pos1.x, pos1.y);
                ctx.lineTo(pos2.x, pos2.y);
                ctx.lineWidth = isMstEdge ? 4 : (isHighlighted ? 3 : 1.5);
                ctx.strokeStyle = isMstEdge ? '#10B981' : (isHighlighted ? '#3B82F6' : '#9CA3AF');
                ctx.stroke();

                const midX = (pos1.x + pos2.x) / 2;
                const midY = (pos1.y + pos2.y) / 2;
                ctx.fillStyle = isMstEdge ? '#059669' : (isHighlighted ? '#2563EB' : '#4B5563');
                ctx.font = 'bold 14px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.save();
                ctx.translate(midX, midY);
                ctx.rotate(Math.atan2(pos2.y - pos1.y, pos2.x - pos1.x));
                if (Math.abs(ctx.getTransform().a) < 0.1) ctx.rotate(Math.PI);
                ctx.fillText(edge.weight, 0, -10);
                ctx.restore();
            });

            nodes.forEach(node => {
                const pos = nodeMap.get(node.id);
                const isHighlighted = drawnState.highlightedNodes.has(node.id);
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 20, 0, 2 * Math.PI);
                ctx.fillStyle = isHighlighted ? '#6EE7B7' : '#E5E7EB';
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = isHighlighted ? '#059669' : '#4B5563';
                ctx.stroke();

                ctx.fillStyle = isHighlighted ? '#065F46' : '#1F2937';
                ctx.font = 'bold 16px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id, pos.x, pos.y);
            });
        }
        
        function resetState() {
             drawnState = { mstEdges: [], highlightedEdge: null, highlightedNodes: new Set() };
             resultEl.textContent = 'Ready to start...';
             weightEl.textContent = 'Total Weight: 0';
             mstAnimationRunning = false;
             drawGraph();
        }
        
        async function runPrims() {
            if (mstAnimationRunning) return;
            mstAnimationRunning = true;
            resetState();
            
            const startNode = 'A';
            const visited = new Set([startNode]);
            const pq = edges.filter(e => e.from === startNode || e.to === startNode);
            pq.sort((a, b) => a.weight - b.weight);

            drawnState.highlightedNodes.add(startNode);
            resultEl.textContent = `Start at node ${startNode}. Highlighted nodes in MST: {${[...visited].join()}}.`;
            drawGraph();
            await new Promise(res => setTimeout(res, 1500));

            while (visited.size < nodes.length && pq.length > 0) {
                const minEdge = pq.shift();
                drawnState.highlightedEdge = minEdge;
                resultEl.textContent = `Considering edge ${minEdge.from}-${minEdge.to} with weight ${minEdge.weight}.`;
                drawGraph();
                await new Promise(res => setTimeout(res, 1500));
                
                const nextNode = visited.has(minEdge.from) ? minEdge.to : minEdge.from;

                if (!visited.has(nextNode)) {
                    visited.add(nextNode);
                    drawnState.mstEdges.push(minEdge);
                    drawnState.highlightedNodes.add(nextNode);
                    resultEl.textContent = `Added edge ${minEdge.from}-${minEdge.to}. Nodes in MST: {${[...visited].join()}}.`;

                    const newEdges = edges.filter(e => (e.from === nextNode || e.to === nextNode) && !(visited.has(e.from) && visited.has(e.to)));
                    pq.push(...newEdges);
                    pq.sort((a, b) => a.weight - b.weight);
                } else {
                     resultEl.textContent = `Skipped edge ${minEdge.from}-${minEdge.to} (would form a cycle).`;
                }
                drawnState.highlightedEdge = null;
                const totalWeight = drawnState.mstEdges.reduce((sum, e) => sum + e.weight, 0);
                weightEl.textContent = `Total Weight: ${totalWeight}`;
                drawGraph();
                await new Promise(res => setTimeout(res, 1500));
            }
             resultEl.textContent = 'Prim\'s Algorithm Complete!';
             mstAnimationRunning = false;
        }

        async function runKruskals() {
            if (mstAnimationRunning) return;
            mstAnimationRunning = true;
            resetState();

            const sortedEdges = [...edges].sort((a, b) => a.weight - b.weight);
            const parent = {};
            nodes.forEach(n => parent[n.id] = n.id);

            function find(i) {
                if (parent[i] === i) return i;
                return find(parent[i]);
            }
            function union(i, j) {
                const rootI = find(i);
                const rootJ = find(j);
                if (rootI !== rootJ) {
                    parent[rootI] = rootJ;
                    return true;
                }
                return false;
            }
            
            resultEl.textContent = 'Sorted all edges by weight.';
            await new Promise(res => setTimeout(res, 1500));
            
            for(const edge of sortedEdges) {
                if(drawnState.mstEdges.length === nodes.length - 1) break;

                drawnState.highlightedEdge = edge;
                resultEl.textContent = `Considering edge ${edge.from}-${edge.to} with weight ${edge.weight}.`;
                drawGraph();
                await new Promise(res => setTimeout(res, 1500));

                if (union(edge.from, edge.to)) {
                    drawnState.mstEdges.push(edge);
                     resultEl.textContent = `Added edge ${edge.from}-${edge.to}.`;
                } else {
                     resultEl.textContent = `Skipped edge ${edge.from}-${edge.to} (would form a cycle).`;
                }
                
                drawnState.highlightedEdge = null;
                const totalWeight = drawnState.mstEdges.reduce((sum, e) => sum + e.weight, 0);
                weightEl.textContent = `Total Weight: ${totalWeight}`;
                drawGraph();
                await new Promise(res => setTimeout(res, 1500));
            }
             resultEl.textContent = 'Kruskal\'s Algorithm Complete!';
             mstAnimationRunning = false;
        }

        document.getElementById('primsBtn').onclick = runPrims;
        document.getElementById('kruskalsBtn').onclick = runKruskals;
        document.getElementById('resetMstBtn').onclick = resetState;
        
        drawGraph();
        new ResizeObserver(drawGraph).observe(canvas.parentElement);
    }
});
</script>
</body>
</html>


