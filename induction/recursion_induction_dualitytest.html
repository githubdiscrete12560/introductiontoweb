<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursion ‚Üî Strong Induction Duality</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 30px;
            border-bottom: 4px solid #3498db;
            padding-bottom: 15px;
        }
        
        .duality-container {
            display: grid;
            grid-template-columns: 1fr 100px 1fr;
            gap: 30px;
            margin: 40px 0;
            align-items: center;
        }
        
        .method-box {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            border: 3px solid #e9ecef;
            min-height: 300px;
        }
        
        .recursion-box {
            border-left: 8px solid #e74c3c;
            background: linear-gradient(135deg, #fdcbf1 0%, #fdcbf1 100%);
        }
        
        .induction-box {
            border-left: 8px solid #27ae60;
            background: linear-gradient(135deg, #d1f2eb 0%, #d1f2eb 100%);
        }
        
        .method-title {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .recursion-title {
            color: #c0392b;
        }
        
        .induction-title {
            color: #27ae60;
        }
        
        .arrow-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .arrow {
            font-size: 3em;
            color: #3498db;
            margin: 10px 0;
            transform: rotate(0deg);
            transition: transform 0.3s ease;
        }
        
        .arrow:hover {
            transform: scale(1.2);
        }
        
        .direction-label {
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.9em;
            text-align: center;
            margin: 5px 0;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            margin: 15px 0;
            overflow-x: auto;
        }
        
        .proof-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Times New Roman', serif;
            font-size: 1.1em;
            margin: 15px 0;
        }
        
        .key-point {
            background: #fff3cd;
            border: 2px solid #ffeaa7;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            border-left: 8px solid #fdcb6e;
        }
        
        .example-section {
            margin: 40px 0;
            padding: 30px;
            background: #f1f2f6;
            border-radius: 15px;
        }
        
        .example-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .comparison-table th {
            background: #3498db;
            color: white;
            padding: 15px;
            text-align: left;
            font-size: 1.1em;
        }
        
        .comparison-table td {
            padding: 15px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .highlight {
            background: #fff3cd;
            padding: 3px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Recursion ‚Üî Strong Induction: The Duality</h1>
        
        <div class="key-point">
            <strong>Key Insight:</strong> Recursion and strong induction are <em>reverse forms</em> of each other - they use the same logical structure but in opposite directions!
        </div>
        
        <div class="duality-container">
            <div class="method-box recursion-box">
                <div class="method-title recursion-title">RECURSION</div>
                <p><strong>Direction:</strong> Large ‚Üí Small</p>
                <p><strong>Mindset:</strong> "To solve this problem, first solve smaller subproblems"</p>
                <p><strong>Structure:</strong></p>
                <ul>
                    <li>Break current problem into smaller pieces</li>
                    <li>Recursively solve each piece</li>
                    <li>Combine results</li>
                </ul>
                <p><strong>Implementation approach</strong></p>
            </div>
            
            <div class="arrow-container">
                <div class="direction-label">TOP-DOWN</div>
                <div class="arrow">‚áä</div>
                <div class="arrow">‚áà</div>
                <div class="direction-label">BOTTOM-UP</div>
            </div>
            
            <div class="method-box induction-box">
                <div class="method-title induction-title">STRONG INDUCTION</div>
                <p><strong>Direction:</strong> Small ‚Üí Large</p>
                <p><strong>Mindset:</strong> "If all smaller cases work, then this case works"</p>
                <p><strong>Structure:</strong></p>
                <ul>
                    <li>Assume smaller cases are true</li>
                    <li>Decompose current case</li>
                    <li>Apply assumptions to prove current case</li>
                </ul>
                <p><strong>Proof approach</strong></p>
            </div>
        </div>
        
        <div class="example-section">
            <div class="example-title">Tree Edges Example: Both Perspectives</div>
            
            <div class="duality-container">
                <div class="method-box recursion-box">
                    <h3>Recursive Algorithm</h3>
                    <div class="code-block">
function countEdges(tree):
    if tree.size == 1:
        return 0
    else:
        subtrees = decompose(tree)
        total = 0
        for each subtree in subtrees:
            total += countEdges(subtree)
        return total + num_connections
                    </div>
                    <p><span class="highlight">Top-down:</span> Break into subtrees, recursively count their edges</p>
                </div>
                
                <div class="arrow-container">
                    <div class="arrow">‚Üî</div>
                    <div style="font-size: 0.8em; text-align: center; margin-top: 5px;">Same Logic!</div>
                </div>
                
                <div class="method-box induction-box">
                    <h3>Strong Induction Proof</h3>
                    <div class="proof-block">
Assume: All trees with < n nodes 
        satisfy |E| = |V| - 1

Prove: Tree T with n nodes 
       satisfies |E| = |V| - 1

Method: Decompose T into subtrees,
        apply assumption to each,
        combine results
                    </div>
                    <p><span class="highlight">Bottom-up:</span> Assume subtrees work, prove main tree works</p>
                </div>
            </div>
        </div>
        
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Aspect</th>
                    <th>Recursion</th>
                    <th>Strong Induction</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Purpose</strong></td>
                    <td>Solve problems computationally</td>
                    <td>Prove mathematical statements</td>
                </tr>
                <tr>
                    <td><strong>Direction</strong></td>
                    <td>Top-down (large ‚Üí small)</td>
                    <td>Bottom-up (small ‚Üí large)</td>
                </tr>
                <tr>
                    <td><strong>Base Case</strong></td>
                    <td>Stopping condition</td>
                    <td>Starting point of proof</td>
                </tr>
                <tr>
                    <td><strong>Decomposition</strong></td>
                    <td>"How do I break this down?"</td>
                    <td>"How did this build up?"</td>
                </tr>
                <tr>
                    <td><strong>Trust</strong></td>
                    <td>Trust that recursive calls work</td>
                    <td>Trust that smaller cases are proven</td>
                </tr>
                <tr>
                    <td><strong>Result</strong></td>
                    <td>Algorithm that computes answer</td>
                    <td>Proof that formula is correct</td>
                </tr>
            </tbody>
        </table>
        
        <div class="key-point">
            <h3>The Deep Connection</h3>
            <p>Every recursive algorithm corresponds to a strong induction proof of its correctness, and every strong induction proof corresponds to a natural recursive solution!</p>
            <ul>
                <li><strong>Recursion proves the algorithm terminates and works</strong></li>
                <li><strong>Strong induction proves why the recursive structure is mathematically sound</strong></li>
                <li><strong>Both use identical decomposition strategies</strong></li>
                <li><strong>Both handle multiple subproblems of varying sizes</strong></li>
            </ul>
        </div>
        
        <div class="example-section">
            <div class="example-title">‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á B: ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÑ‡∏ö‡∏ô‡∏≤‡∏£‡∏µ‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡πÅ‡∏ö‡∏ö | Example B: Perfect Binary Tree</div>
            
            <div style="background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; padding: 20px; border-radius: 15px; margin: 15px 0; font-size: 1.2em; font-weight: 500;">
                <strong>Theorem | ‡∏ó‡∏§‡∏©‡∏é‡∏µ‡∏ö‡∏ó:</strong> A perfect binary tree of height h has exactly N(h) = 2^(h+1) - 1 nodes.<br>
                <span style="font-size: 0.9em; opacity: 0.9;">‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÑ‡∏ö‡∏ô‡∏≤‡∏£‡∏µ‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á h ‡∏°‡∏µ‡πÇ‡∏´‡∏ô‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô N(h) = 2^(h+1) - 1 ‡πÇ‡∏´‡∏ô‡∏î‡∏û‡∏≠‡∏î‡∏µ</span>
            </div>

            <div style="background: #fff3cd; border: 2px solid #ffeaa7; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <strong>Definition | ‡∏Ñ‡∏≥‡∏ô‡∏¥‡∏¢‡∏≤‡∏°:</strong><br>
                <span style="color: #8e44ad;">‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÑ‡∏ö‡∏ô‡∏≤‡∏£‡∏µ‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á h ‡∏°‡∏µ‡πÉ‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∂‡∏Å h ‡πÅ‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß‡∏°‡∏µ‡∏•‡∏π‡∏Å‡∏™‡∏≠‡∏á‡∏ï‡∏±‡∏ß</span><br>
                <span style="color: #2c3e50; font-style: italic;">A perfect binary tree of height h has all leaves at depth h and every internal node has two children.</span>
            </div>

            <h4 style="color: #27ae60; margin: 20px 0 10px 0;">‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á | Proof by Induction on Height</h4>

            <div style="background: #e8f6f3; border-left: 4px solid #1abc9c; padding: 15px; margin: 15px 0; border-radius: 4px;">
                <div style="color: #16a085; font-weight: bold; margin-bottom: 8px;">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏Å‡∏£‡∏ì‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô | Step 1: Base Case</div>
                <p><strong>h = 0:</strong> A perfect binary tree of height 0 is just a single leaf node.</p>
                <p><span style="color: #8e44ad;">‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÑ‡∏ö‡∏ô‡∏≤‡∏£‡∏µ‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á 0 ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡πÇ‡∏´‡∏ô‡∏î‡πÉ‡∏ö‡πÄ‡∏î‡∏µ‡∏¢‡∏ß</span></p>
                <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 10px 0;">
                    N(0) = 1<br>
                    2^(0+1) - 1 = 2¬π - 1 = 2 - 1 = 1 ‚úì
                </div>
                <p>Base case holds! | ‡∏Å‡∏£‡∏ì‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏£‡∏¥‡∏á!</p>
            </div>

            <div style="background: #e8f6f3; border-left: 4px solid #1abc9c; padding: 15px; margin: 15px 0; border-radius: 4px;">
                <div style="color: #16a085; font-weight: bold; margin-bottom: 8px;">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ê‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥ | Step 2: Inductive Hypothesis</div>
                <p><strong>Assume:</strong> For some k ‚â• 0, N(k) = 2^(k+1) - 1</p>
                <p><span style="color: #8e44ad;">‡∏™‡∏°‡∏°‡∏ï‡∏¥: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö k ‚â• 0 ‡∏ö‡∏≤‡∏á‡∏Ñ‡πà‡∏≤, N(k) = 2^(k+1) - 1</span></p>
                <p style="font-style: italic;">That is, the formula holds for perfect binary trees of height k.</p>
            </div>

            <div style="background: #e8f6f3; border-left: 4px solid #1abc9c; padding: 15px; margin: 15px 0; border-radius: 4px;">
                <div style="color: #16a085; font-weight: bold; margin-bottom: 8px;">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3: ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥ | Step 3: Inductive Step</div>
                <p><strong>Goal:</strong> Prove N(k+1) = 2^(k+2) - 1</p>
                <p><span style="color: #8e44ad;">‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢: ‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå N(k+1) = 2^(k+2) - 1</span></p>
                
                <p><strong>Structure Analysis | ‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á:</strong></p>
                <p>A perfect binary tree of height k+1 consists of:</p>
                <ul style="margin-left: 20px;">
                    <li>1 root node | 1 ‡πÇ‡∏´‡∏ô‡∏î‡∏£‡∏≤‡∏Å</li>
                    <li>2 perfect subtrees of height k | 2 ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏¢‡πà‡∏≠‡∏¢‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á k</li>
                </ul>

                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0; text-align: left;">
                    <div style="font-family: monospace; margin: 8px 0; font-size: 1.05em;">N(k+1) = 1 + 2¬∑N(k)</div>
                    <div style="font-family: monospace; margin: 8px 0; font-size: 1.05em;">       = 1 + 2¬∑(2^(k+1) - 1)  <span style="color: #666; font-family: sans-serif;">[by inductive hypothesis]</span></div>
                    <div style="font-family: monospace; margin: 8px 0; font-size: 1.05em;">       = 1 + 2¬∑2^(k+1) - 2¬∑1</div>
                    <div style="font-family: monospace; margin: 8px 0; font-size: 1.05em;">       = 1 + 2^(k+2) - 2</div>
                    <div style="font-family: monospace; margin: 8px 0; font-size: 1.05em;">       = 2^(k+2) - 1 ‚úì</div>
                </div>
                <p>The inductive step holds! | ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏£‡∏¥‡∏á!</p>
            </div>

            <div style="background: linear-gradient(135deg, #00b894, #00a085); color: white; padding: 20px; border-radius: 15px; margin: 15px 0; font-size: 1.3em; font-weight: 600;">
                ‚úì By induction, N(h) = 2^(h+1) - 1 for all h ‚â• 0<br>
                <span style="font-size: 0.8em;">‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥, N(h) = 2^(h+1) - 1 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å h ‚â• 0</span>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                <div>
                    <h4>‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì | Example Calculations</h4>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 8px; font-size: 0.9em;">
h=0: N(0) = 2¬π - 1 = 1
h=1: N(1) = 2¬≤ - 1 = 3  
h=2: N(2) = 2¬≥ - 1 = 7
h=3: N(3) = 2‚Å¥ - 1 = 15
                    </div>
                </div>
                <div>
                    <h4>Visual Verification | ‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢‡∏†‡∏≤‡∏û</h4>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 8px; font-size: 0.85em;">
Height 0:    ‚Ä¢           (1 node)

Height 1:    ‚Ä¢           (3 nodes)
            / \
           ‚Ä¢   ‚Ä¢

Height 2:    ‚Ä¢           (7 nodes)  
           / \
          ‚Ä¢   ‚Ä¢
         / \ / \
        ‚Ä¢  ‚Ä¢ ‚Ä¢  ‚Ä¢
                    </div>
                </div>
            </div>
        </div>

        <div class="example-section">
            <div class="example-title">‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á C: ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡∏£‡∏ß‡∏à (‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏°‡∏∏‡∏°‡∏°‡∏≠‡∏á) | Example C: Traversal Lengths (Both Perspectives)</div>
            
            <div style="background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; padding: 20px; border-radius: 15px; margin: 15px 0; font-size: 1.2em; font-weight: 500;">
                <strong>Theorem | ‡∏ó‡∏§‡∏©‡∏é‡∏µ‡∏ö‡∏ó:</strong> For any binary tree T: |preorder| = |inorder| = |postorder| = size(T)<br>
                <span style="font-size: 0.9em; opacity: 0.9;">‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÑ‡∏ö‡∏ô‡∏≤‡∏£‡∏µ T ‡πÉ‡∏î‡πÜ: |preorder| = |inorder| = |postorder| = size(T)</span>
            </div>

            <div style="background: #fff3cd; border: 2px solid #ffeaa7; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <strong>Concrete Example Tree | ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏à‡∏£‡∏¥‡∏á:</strong><br>
                <div style="font-family: monospace; background: #f8f9fa; padding: 12px; border-radius: 6px; margin: 10px 0; font-size: 0.9em; text-align: center;">
    1
   / \
  2   3
 / \
4   5

Size = 5 nodes | ‡∏Ç‡∏ô‡∏≤‡∏î = 5 ‡πÇ‡∏´‡∏ô‡∏î
                </div>
            </div>

            <h4 style="color: #e74c3c; margin: 20px 0 15px 0; font-size: 1.4em;">üîÑ Preorder Traversal | ‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡∏£‡∏ß‡∏à Preorder</h4>

            <div style="display: grid; grid-template-columns: 1fr 100px 1fr; gap: 20px; margin: 20px 0; align-items: center;">
                <div style="background: #fdcbf1; padding: 20px; border-radius: 15px; border-left: 8px solid #e74c3c; min-height: 300px;">
                    <h4 style="color: #c0392b; margin-bottom: 15px;">Recursive Algorithm | ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ã‡πâ‡∏≥</h4>
                    <p style="margin-bottom: 15px;"><strong>Top-down:</strong> Build result by visiting root first</p>
                    <p style="margin-bottom: 15px; font-style: italic; color: #8e44ad;">‡∏à‡∏≤‡∏Å‡∏ö‡∏ô‡∏•‡∏á‡∏•‡πà‡∏≤‡∏á: ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÇ‡∏î‡∏¢‡πÄ‡∏¢‡∏∑‡∏≠‡∏ô‡∏£‡∏≤‡∏Å‡∏Å‡πà‡∏≠‡∏ô</p>
                    
                    <div style="background: #2c3e50; color: #ecf0f1; padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; margin: 10px 0; font-size: 0.8em;">
def preorder(T):
    if T is None:
        return []
    else:
        return ([T.key] + 
                preorder(T.left) + 
                preorder(T.right))
                    </div>
                    
                    <p><strong>‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì | Calculation:</strong></p>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.8em;">
preorder(1) = [1] + preorder(2) + preorder(3)
preorder(2) = [2] + [4] + [5] = [2,4,5]  
preorder(3) = [3]
Result: [1,2,4,5,3] | Length = 5
                    </div>
                </div>
                
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <div style="font-size: 2.5em; color: #3498db; margin: 10px 0;">‚Üî</div>
                    <div style="font-weight: bold; color: #2c3e50; font-size: 0.8em; text-align: center;">Same Logic!</div>
                </div>
                
                <div style="background: #d1f2eb; padding: 20px; border-radius: 15px; border-left: 8px solid #27ae60; min-height: 300px;">
                    <h4 style="color: #27ae60; margin-bottom: 15px;">Strong Induction Proof | ‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥‡πÅ‡∏Å‡∏ô‡πÅ‡∏Ç‡πá‡∏á</h4>
                    <p style="margin-bottom: 15px;"><strong>Bottom-up:</strong> Assume subtrees work, prove whole works</p>
                    <p style="margin-bottom: 15px; font-style: italic; color: #8e44ad;">‡∏à‡∏≤‡∏Å‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏ö‡∏ô: ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏¢‡πà‡∏≠‡∏¢‡∏ó‡∏≥‡∏á‡∏≤‡∏ô ‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡∏ß‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏ï‡πâ‡∏ô‡∏ó‡∏≥‡∏á‡∏≤‡∏ô</p>
                    
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin: 10px 0; font-size: 0.85em;">
                        <strong>IH:</strong> |preorder(L)| = size(L), |preorder(R)| = size(R)
                        <br><br>
                        <strong>Proof:</strong><br>
                        |preorder(T)| = |[key]| + |preorder(L)| + |preorder(R)|<br>
                        = 1 + size(L) + size(R) = size(T) ‚úì
                    </div>
                    
                    <p><strong>‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö | Verification:</strong></p>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.8em;">
|preorder(1)| = 1 + |preorder(2)| + |preorder(3)|
                = 1 + 3 + 1 = 5 = size(1) ‚úì
                    </div>
                </div>
            </div>

            <h4 style="color: #e74c3c; margin: 20px 0 15px 0; font-size: 1.4em;">üîÑ Inorder Traversal | ‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡∏£‡∏ß‡∏à Inorder</h4>

            <div style="display: grid; grid-template-columns: 1fr 100px 1fr; gap: 20px; margin: 20px 0; align-items: center;">
                <div style="background: #fdcbf1; padding: 20px; border-radius: 15px; border-left: 8px solid #e74c3c; min-height: 300px;">
                    <h4 style="color: #c0392b; margin-bottom: 15px;">Recursive Algorithm | ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ã‡πâ‡∏≥</h4>
                    <p style="margin-bottom: 15px;"><strong>Top-down:</strong> Visit left, root, then right</p>
                    <p style="margin-bottom: 15px; font-style: italic; color: #8e44ad;">‡∏à‡∏≤‡∏Å‡∏ö‡∏ô‡∏•‡∏á‡∏•‡πà‡∏≤‡∏á: ‡πÄ‡∏¢‡∏∑‡∏≠‡∏ô‡∏ã‡πâ‡∏≤‡∏¢ ‡∏£‡∏≤‡∏Å ‡πÅ‡∏•‡πâ‡∏ß‡∏Ç‡∏ß‡∏≤</p>
                    
                    <div style="background: #2c3e50; color: #ecf0f1; padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; margin: 10px 0; font-size: 0.8em;">
def inorder(T):
    if T is None:
        return []
    else:
        return (inorder(T.left) + 
                [T.key] + 
                inorder(T.right))
                    </div>
                    
                    <p><strong>‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì | Calculation:</strong></p>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.8em;">
inorder(1) = inorder(2) + [1] + inorder(3)
inorder(2) = [4] + [2] + [5] = [4,2,5]
inorder(3) = [3]  
Result: [4,2,5,1,3] | Length = 5
                    </div>
                </div>
                
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <div style="font-size: 2.5em; color: #3498db; margin: 10px 0;">‚Üî</div>
                    <div style="font-weight: bold; color: #2c3e50; font-size: 0.8em; text-align: center;">Same Logic!</div>
                </div>
                
                <div style="background: #d1f2eb; padding: 20px; border-radius: 15px; border-left: 8px solid #27ae60; min-height: 300px;">
                    <h4 style="color: #27ae60; margin-bottom: 15px;">Strong Induction Proof | ‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥‡πÅ‡∏Å‡∏ô‡πÅ‡∏Ç‡πá‡∏á</h4>
                    <p style="margin-bottom: 15px;"><strong>Bottom-up:</strong> Assume subtrees work, prove whole works</p>
                    <p style="margin-bottom: 15px; font-style: italic; color: #8e44ad;">‡∏à‡∏≤‡∏Å‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏ö‡∏ô: ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏¢‡πà‡∏≠‡∏¢‡∏ó‡∏≥‡∏á‡∏≤‡∏ô ‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡∏ß‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏ï‡πâ‡∏ô‡∏ó‡∏≥‡∏á‡∏≤‡∏ô</p>
                    
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin: 10px 0; font-size: 0.85em;">
                        <strong>IH:</strong> |inorder(L)| = size(L), |inorder(R)| = size(R)
                        <br><br>
                        <strong>Proof:</strong><br>
                        |inorder(T)| = |inorder(L)| + |[key]| + |inorder(R)|<br>
                        = size(L) + 1 + size(R) = size(T) ‚úì
                    </div>
                    
                    <p><strong>‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö | Verification:</strong></p>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.8em;">
|inorder(1)| = |inorder(2)| + 1 + |inorder(3)|
              = 3 + 1 + 1 = 5 = size(1) ‚úì
                    </div>
                </div>
            </div>

            <h4 style="color: #e74c3c; margin: 20px 0 15px 0; font-size: 1.4em;">üîÑ Postorder Traversal | ‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡∏£‡∏ß‡∏à Postorder</h4>

            <div style="display: grid; grid-template-columns: 1fr 100px 1fr; gap: 20px; margin: 20px 0; align-items: center;">
                <div style="background: #fdcbf1; padding: 20px; border-radius: 15px; border-left: 8px solid #e74c3c; min-height: 300px;">
                    <h4 style="color: #c0392b; margin-bottom: 15px;">Recursive Algorithm | ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ã‡πâ‡∏≥</h4>
                    <p style="margin-bottom: 15px;"><strong>Top-down:</strong> Visit children before root</p>
                    <p style="margin-bottom: 15px; font-style: italic; color: #8e44ad;">‡∏à‡∏≤‡∏Å‡∏ö‡∏ô‡∏•‡∏á‡∏•‡πà‡∏≤‡∏á: ‡πÄ‡∏¢‡∏∑‡∏≠‡∏ô‡∏•‡∏π‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡∏£‡∏≤‡∏Å</p>
                    
                    <div style="background: #2c3e50; color: #ecf0f1; padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; margin: 10px 0; font-size: 0.8em;">
def postorder(T):
    if T is None:
        return []
    else:
        return (postorder(T.left) + 
                postorder(T.right) +
                [T.key])
                    </div>
                    
                    <p><strong>‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì | Calculation:</strong></p>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.8em;">
postorder(1) = postorder(2) + postorder(3) + [1]
postorder(2) = [4] + [5] + [2] = [4,5,2]
postorder(3) = [3]
Result: [4,5,2,3,1] | Length = 5
                    </div>
                </div>
                
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <div style="font-size: 2.5em; color: #3498db; margin: 10px 0;">‚Üî</div>
                    <div style="font-weight: bold; color: #2c3e50; font-size: 0.8em; text-align: center;">Same Logic!</div>
                </div>
                
                <div style="background: #d1f2eb; padding: 20px; border-radius: 15px; border-left: 8px solid #27ae60; min-height: 300px;">
                    <h4 style="color: #27ae60; margin-bottom: 15px;">Strong Induction Proof | ‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥‡πÅ‡∏Å‡∏ô‡πÅ‡∏Ç‡πá‡∏á</h4>
                    <p style="margin-bottom: 15px;"><strong>Bottom-up:</strong> Assume subtrees work, prove whole works</p>
                    <p style="margin-bottom: 15px; font-style: italic; color: #8e44ad;">‡∏à‡∏≤‡∏Å‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏ö‡∏ô: ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏¢‡πà‡∏≠‡∏¢‡∏ó‡∏≥‡∏á‡∏≤‡∏ô ‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡∏ß‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏ï‡πâ‡∏ô‡∏ó‡∏≥‡∏á‡∏≤‡∏ô</p>
                    
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin: 10px 0; font-size: 0.85em;">
                        <strong>IH:</strong> |postorder(L)| = size(L), |postorder(R)| = size(R)
                        <br><br>
                        <strong>Proof:</strong><br>
                        |postorder(T)| = |postorder(L)| + |postorder(R)| + |[key]|<br>
                        = size(L) + size(R) + 1 = size(T) ‚úì
                    </div>
                    
                    <p><strong>‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö | Verification:</strong></p>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.8em;">
|postorder(1)| = |postorder(2)| + |postorder(3)| + 1
                = 3 + 1 + 1 = 5 = size(1) ‚úì
                    </div>
                </div>
            </div>

            <div style="background: linear-gradient(45deg, #3498db, #9b59b6); color: white; padding: 20px; border-radius: 10px; margin: 20px 0; text-align: center;">
                <h4 style="margin-bottom: 15px; font-size: 1.3em;">üéØ The Deep Connection | ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÇ‡∏¢‡∏á‡∏•‡∏∂‡∏Å‡∏ã‡∏∂‡πâ‡∏á</h4>
                <p style="margin-bottom: 10px; font-size: 1.1em;">Each recursive algorithm has an identical strong induction proof!</p>
                <p style="margin-bottom: 10px; font-style: italic; color: #ecf0f1;">‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ã‡πâ‡∏≥‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥‡πÅ‡∏Å‡∏ô‡πÅ‡∏Ç‡πá‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô!</p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                        <strong>Algorithm:</strong> Break into subproblems, solve recursively, combine<br>
                        <em>‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°: ‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏¢‡πà‡∏≠‡∏¢ ‡πÅ‡∏Å‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ã‡πâ‡∏≥ ‡∏£‡∏ß‡∏°‡∏ú‡∏•</em>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                        <strong>Induction:</strong> Assume subproblems work, prove combination works<br>
                        <em>‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥: ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏¢‡πà‡∏≠‡∏¢‡∏ó‡∏≥‡∏á‡∏≤‡∏ô ‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡∏Å‡∏≤‡∏£‡∏£‡∏ß‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô</em>
                    </div>
                </div>
            </div>

            <div style="background: #f8f9fa; padding: 20px; border-radius: 15px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-bottom: 15px; text-align: center;">üìä Complete Verification | ‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; text-align: center;">
                    <div>
                        <h5 style="color: #e74c3c; margin-bottom: 10px;">Preorder</h5>
                        <div style="font-family: monospace; background: #fff; padding: 10px; border-radius: 4px; font-size: 0.85em;">
[1, 2, 4, 5, 3]<br>
Length = 5 ‚úì
                        </div>
                    </div>
                    <div>
                        <h5 style="color: #e74c3c; margin-bottom: 10px;">Inorder</h5>
                        <div style="font-family: monospace; background: #fff; padding: 10px; border-radius: 4px; font-size: 0.85em;">
[4, 2, 5, 1, 3]<br>
Length = 5 ‚úì
                        </div>
                    </div>
                    <div>
                        <h5 style="color: #e74c3c; margin-bottom: 10px;">Postorder</h5>
                        <div style="font-family: monospace; background: #fff; padding: 10px; border-radius: 4px; font-size: 0.85em;">
[4, 5, 2, 3, 1]<br>
Length = 5 ‚úì
                        </div>
                    </div>
                </div>
                <p style="text-align: center; margin-top: 15px; font-weight: bold; color: #27ae60;">
                    All traversals visit each node exactly once ‚Üí Length equals tree size<br>
                    <span style="color: #8e44ad; font-style: italic;">‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡∏£‡∏ß‡∏à‡∏ó‡∏∏‡∏Å‡πÅ‡∏ö‡∏ö‡πÄ‡∏¢‡∏∑‡∏≠‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î‡∏û‡∏≠‡∏î‡∏µ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‚Üí ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ</span>
                </p>
            </div>
        </div>

        <div class="example-section">
            <div class="example-title">‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á D: ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥ Inorder ‡∏Ç‡∏≠‡∏á BST | Example D: BST Inorder Property</div>
            
            <div style="background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; padding: 20px; border-radius: 15px; margin: 15px 0; font-size: 1.2em; font-weight: 500;">
                <strong>Theorem | ‡∏ó‡∏§‡∏©‡∏é‡∏µ‡∏ö‡∏ó:</strong> For any BST T, inorder(T) is a strictly increasing sequence.<br>
                <span style="font-size: 0.9em; opacity: 0.9;">‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö BST T ‡πÉ‡∏î‡πÜ, inorder(T) ‡πÄ‡∏õ‡πá‡∏ô‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡πà‡∏á‡∏Ñ‡∏£‡∏±‡∏î</span>
            </div>

            <div style="background: #fff3cd; border: 2px solid #ffeaa7; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <strong>Important Terminology | ‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç:</strong><br>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 10px 0;">
                    <div>
                        <strong style="color: #e74c3c;">Root</strong> = ‡πÇ‡∏´‡∏ô‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ö‡∏ô‡∏™‡∏∏‡∏î | The topmost node position<br>
                        <strong style="color: #e74c3c;">Key</strong> = ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö‡πÉ‡∏ô‡πÇ‡∏´‡∏ô‡∏î | The data/value stored in a node
                    </div>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 8px; border-radius: 4px; font-size: 0.8em;">
Node = {position, key}<br>
key(root) = value at root<br>
key(T) = key at node T
                    </div>
                </div>
            </div>

            <div style="background: #fff3cd; border: 2px solid #ffeaa7; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <strong>BST Invariant | ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏°‡πà‡πÅ‡∏õ‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ç‡∏≠‡∏á BST:</strong><br>
                <span style="color: #8e44ad;">‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö BST ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏∏‡∏ç‡πÅ‡∏à‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô: ‡∏Å‡∏∏‡∏ç‡πÅ‡∏à‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏¢‡πà‡∏≠‡∏¢‡∏ã‡πâ‡∏≤‡∏¢ < key(T) < ‡∏Å‡∏∏‡∏ç‡πÅ‡∏à‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏¢‡πà‡∏≠‡∏¢‡∏Ç‡∏ß‡∏≤</span><br>
                <span style="color: #2c3e50; font-style: italic;">For BST with distinct keys: all keys in left subtree < key(T) < all keys in right subtree</span>
                <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 10px 0; text-align: center; font-family: 'Times New Roman', serif; font-size: 1.1em;">
                    ‚àÄx ‚àà left subtree: x < key(T)<br>
                    ‚àÄy ‚àà right subtree: y > key(T)
                </div>
                <p style="margin: 8px 0; font-size: 0.9em; color: #666;">
                    <strong>Note:</strong> key(T) means "the key stored at node T" | ‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á "‡∏Å‡∏∏‡∏ç‡πÅ‡∏à‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏ô‡∏î T"
                </p>
            </div>

            <h4 style="color: #27ae60; margin: 20px 0 10px 0;">‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥‡πÄ‡∏ä‡∏¥‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á | Proof by Structural Induction</h4>

            <div style="background: #e8f6f3; border-left: 4px solid #1abc9c; padding: 15px; margin: 15px 0; border-radius: 4px;">
                <div style="color: #16a085; font-weight: bold; margin-bottom: 8px;">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏Å‡∏£‡∏ì‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô | Step 1: Base Cases</div>
                
                <p><strong>Case 1 - Empty Tree | ‡∏Å‡∏£‡∏ì‡∏µ 1 - ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ß‡πà‡∏≤‡∏á:</strong> T = ‚àÖ</p>
                <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 10px 0;">
                    inorder(‚àÖ) = []<br>
                    Empty sequence is trivially sorted ‚úì
                </div>

                <p><strong>Case 2 - Single Node | ‡∏Å‡∏£‡∏ì‡∏µ 2 - ‡πÇ‡∏´‡∏ô‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß:</strong> T = Node(key, ‚àÖ, ‚àÖ)</p>
                <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 10px 0;">
                    inorder(T) = [] ++ [key] ++ [] = [key]<br>
                    Single element sequence is trivially sorted ‚úì
                </div>
                <p>Base cases hold! | ‡∏Å‡∏£‡∏ì‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏£‡∏¥‡∏á!</p>
            </div>

            <div style="background: #e8f6f3; border-left: 4px solid #1abc9c; padding: 15px; margin: 15px 0; border-radius: 4px;">
                <div style="color: #16a085; font-weight: bold; margin-bottom: 8px;">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ê‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥ | Step 2: Inductive Hypothesis</div>
                <p><strong>Assume:</strong> For all BST subtrees L and R with size < size(T):</p>
                <p><span style="color: #8e44ad;">‡∏™‡∏°‡∏°‡∏ï‡∏¥: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏¢‡πà‡∏≠‡∏¢ BST ‡∏ó‡∏∏‡∏Å‡∏ï‡πâ‡∏ô L ‡πÅ‡∏•‡∏∞ R ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡∏ô‡∏≤‡∏î < size(T):</span></p>
                <div style="background: #f8f9fa; padding: 12px; border-radius: 4px; margin: 10px 0;">
                    <div style="font-family: 'Times New Roman', serif; font-size: 1.1em; text-align: center; margin-bottom: 8px;">
                        inorder(L) and inorder(R) are strictly increasing
                    </div>
                    <p style="margin: 0; font-size: 0.9em; text-align: center; font-style: italic;">
                        inorder(L) ‡πÅ‡∏•‡∏∞ inorder(R) ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡πà‡∏á‡∏Ñ‡∏£‡∏±‡∏î
                    </p>
                </div>
            </div>

            <div style="background: #e8f6f3; border-left: 4px solid #1abc9c; padding: 15px; margin: 15px 0; border-radius: 4px;">
                <div style="color: #16a085; font-weight: bold; margin-bottom: 8px;">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3: ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥ | Step 3: Inductive Step</div>
                <p><strong>Goal:</strong> Prove inorder(T) is sorted for T = Node(key, L, R)</p>
                <p><span style="color: #8e44ad;">‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢: ‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡∏ß‡πà‡∏≤ inorder(T) ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö T = Node(key, L, R)</span></p>
                
                <p><strong>Structure Analysis | ‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á:</strong></p>
                <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 10px 0;">
                    inorder(T) = inorder(L) ++ [key] ++ inorder(R)
                </div>

                <p><strong>Sortedness Proof | ‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö:</strong></p>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0; text-align: left;">
                    <p style="margin: 8px 0;"><strong>1.</strong> By IH: inorder(L) and inorder(R) are sorted</p>
                    <p style="margin: 8px 0; font-style: italic; color: #666;">‡πÇ‡∏î‡∏¢ IH: inorder(L) ‡πÅ‡∏•‡∏∞ inorder(R) ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÅ‡∏•‡πâ‡∏ß</p>
                    
                    <p style="margin: 8px 0;"><strong>2.</strong> By BST invariant:</p>
                    <div style="font-family: monospace; margin: 8px 0; background: #e9ecef; padding: 8px; border-radius: 4px;">
                        ‚àÄx ‚àà inorder(L): x < key
                        ‚àÄy ‚àà inorder(R): y > key
                    </div>
                    
                    <p style="margin: 8px 0;"><strong>3.</strong> Therefore: max(inorder(L)) < key < min(inorder(R))</p>
                    <p style="margin: 8px 0; font-style: italic; color: #666;">‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô: max(inorder(L)) < key < min(inorder(R))</p>
                    
                    <p style="margin: 8px 0;"><strong>4.</strong> Concatenation preserves sorting:</p>
                    <div style="font-family: monospace; margin: 8px 0; background: #e9ecef; padding: 8px; border-radius: 4px;">
                        inorder(L) ++ [key] ++ inorder(R) is strictly increasing ‚úì
                    </div>
                </div>
            </div>

            <div style="background: linear-gradient(135deg, #00b894, #00a085); color: white; padding: 20px; border-radius: 15px; margin: 15px 0; font-size: 1.3em; font-weight: 600;">
                ‚úì By structural induction, inorder(T) is sorted for all BST T<br>
                <span style="font-size: 0.8em;">‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥‡πÄ‡∏ä‡∏¥‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á, inorder(T) ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö BST T ‡∏ó‡∏∏‡∏Å‡∏ï‡πâ‡∏ô</span>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                <div>
                    <h4>‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á BST ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ | BST Example with Clarification</h4>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 8px; font-size: 0.85em;">
BST:         5  ‚Üê root node, key(root) = 5
           /   \
          3     8  ‚Üê internal nodes  
         / \   / \
        1   4 7   9  ‚Üê leaf nodes

<strong style="color: #e74c3c;">For root node (position = root, key = 5):</strong>
Left subtree keys: {1, 3, 4} < 5 ‚úì
Right subtree keys: {7, 8, 9} > 5 ‚úì

<strong style="color: #e74c3c;">For node with key = 3:</strong>  
Left subtree keys: {1} < 3 ‚úì
Right subtree keys: {4} > 3 ‚úì

inorder(BST) = [1, 3, 4, 5, 7, 8, 9] ‚úì Sorted!
                    </div>
                    <p style="font-size: 0.9em; margin-top: 10px;">
                        <strong>‡∏Å‡∏∏‡∏ç‡πÅ‡∏à | Key insight:</strong> key(T) ‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á "‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏ô‡∏î T" ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÇ‡∏´‡∏ô‡∏î<br>
                        key(T) means "value stored at node T", not the node position itself
                    </p>
                </div>
                <div>
                    <h4>Why BST Invariant Works for Inorder | ‡∏ó‡∏≥‡πÑ‡∏° BST Invariant ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏Å‡∏±‡∏ö Inorder</h4>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; font-size: 0.9em;">
                        <p style="margin-bottom: 12px;"><strong>Inorder pattern | ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö Inorder:</strong></p>
                        <div style="font-family: monospace; background: #e9ecef; padding: 8px; border-radius: 4px; margin: 8px 0; font-size: 0.85em;">
inorder(T) = inorder(left) + [key(T)] + inorder(right)
                        </div>
                        
                        <p style="margin-bottom: 8px; margin-top: 15px;"><strong>BST guarantee | ‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô‡∏Ç‡∏≠‡∏á BST:</strong></p>
                        <p style="margin-bottom: 6px; font-size: 0.85em;">‚Ä¢ All values in inorder(left) < key(T)</p>
                        <p style="margin-bottom: 6px; font-size: 0.85em; color: #8e44ad;">‚Ä¢ ‡∏Ñ‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô inorder(left) < key(T)</p>
                        <p style="margin-bottom: 6px; font-size: 0.85em;">‚Ä¢ All values in inorder(right) > key(T)</p>
                        <p style="margin-bottom: 6px; font-size: 0.85em; color: #8e44ad;">‚Ä¢ ‡∏Ñ‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô inorder(right) > key(T)</p>
                        
                        <p style="margin-top: 15px; margin-bottom: 8px;"><strong>Result | ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:</strong></p>
                        <p style="margin-bottom: 0; font-size: 0.85em;">Concatenation preserves sorted order!</p>
                        <p style="margin-bottom: 0; font-size: 0.85em; color: #8e44ad;">‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏á!</p>
                    </div>
                </div>
            </div>

            <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #2196f3;">
                <strong>Application | ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå:</strong> This theorem explains why inorder traversal is used for sorted enumeration of BST contents.<br>
                <span style="color: #8e44ad;">‡∏ó‡∏§‡∏©‡∏é‡∏µ‡∏ö‡∏ó‡∏ô‡∏µ‡πâ‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏ß‡πà‡∏≤‡∏ó‡∏≥‡πÑ‡∏°‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡∏£‡∏ß‡∏à inorder ‡∏à‡∏∂‡∏á‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡∏Å‡πÅ‡∏à‡∏á‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤ BST ‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö</span><br><br>
                <strong>Corollary | ‡∏ö‡∏ó‡∏™‡∏£‡∏∏‡∏õ:</strong> BST search, insert, and delete operations preserve this property.<br>
                <span style="color: #8e44ad;">‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ ‡∏Å‡∏≤‡∏£‡πÅ‡∏ó‡∏£‡∏Å ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡πÉ‡∏ô BST ‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏ô‡∏µ‡πâ‡πÑ‡∏ß‡πâ</span>
            </div>
        </div>

        <div class="example-section">
            <div class="example-title">Why "Strong" for Both? | ‡∏ó‡∏≥‡πÑ‡∏° "‡πÅ‡∏Å‡∏ô‡πÅ‡∏Ç‡πá‡∏á" ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á?</div>
            <p><span style="color: #8e44ad;">‡∏ó‡∏±‡πâ‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ã‡πâ‡∏≥‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏™‡∏π‡∏à‡∏ô‡πå‡πÄ‡∏´‡∏ô‡∏µ‡πà‡∏¢‡∏ß‡∏ô‡∏≥‡πÄ‡∏õ‡πá‡∏ô "‡πÅ‡∏Å‡∏ô‡πÅ‡∏Ç‡πá‡∏á" ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÑ‡∏î‡πâ:</span></p>
            <p><span style="color: #2c3e50; font-style: italic;">Both recursion and strong induction are "strong" because they can handle:</span></p>
            <ul style="font-size: 1.1em;">
                <li><strong>‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏¢‡πà‡∏≠‡∏¢‡∏´‡∏•‡∏≤‡∏¢‡∏ï‡∏±‡∏ß | Multiple subproblems</strong> (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÅ‡∏Ñ‡πà‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏•‡πá‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏´‡∏ô‡∏∂‡πà‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß | not just one smaller case)</li>
                <li><strong>‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏¢‡πà‡∏≠‡∏¢‡∏Ç‡∏≠‡∏á‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô | Subproblems of different sizes</strong> (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÅ‡∏Ñ‡πà‡∏Ç‡∏ô‡∏≤‡∏î n-1 | not just size n-1)</li>
                <li><strong>‡∏Å‡∏≤‡∏£‡πÅ‡∏¢‡∏Å‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô | Flexible decomposition</strong> (‡∏´‡∏•‡∏≤‡∏¢‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡πà‡∏á‡∏õ‡∏±‡∏ç‡∏´‡∏≤ | many ways to break down the problem)</li>
            </ul>
            <p><span style="color: #8e44ad;">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô‡∏ô‡∏µ‡πâ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡πÅ‡∏ö‡πà‡∏á‡πÅ‡∏¢‡∏Å‡πÅ‡∏•‡∏∞‡∏û‡∏¥‡∏ä‡∏¥‡∏ï ‡πÅ‡∏•‡∏∞‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ã‡πâ‡∏≥‡∏ó‡∏µ‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô!</span></p>
            <p style="font-style: italic;">This flexibility makes them perfect for tree problems, divide-and-conquer algorithms, and complex recursive structures!</p>
        </div>
    </div>
</body>
</html>