<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursion ↔ Strong Induction Duality</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 30px;
            border-bottom: 4px solid #3498db;
            padding-bottom: 15px;
        }
        
        .duality-container {
            display: grid;
            grid-template-columns: 1fr 100px 1fr;
            gap: 30px;
            margin: 40px 0;
            align-items: center;
        }
        
        .method-box {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            border: 3px solid #e9ecef;
            min-height: 300px;
        }
        
        .recursion-box {
            border-left: 8px solid #e74c3c;
            background: linear-gradient(135deg, #fdcbf1 0%, #fdcbf1 100%);
        }
        
        .induction-box {
            border-left: 8px solid #27ae60;
            background: linear-gradient(135deg, #d1f2eb 0%, #d1f2eb 100%);
        }
        
        .method-title {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .recursion-title {
            color: #c0392b;
        }
        
        .induction-title {
            color: #27ae60;
        }
        
        .arrow-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .arrow {
            font-size: 3em;
            color: #3498db;
            margin: 10px 0;
            transform: rotate(0deg);
            transition: transform 0.3s ease;
        }
        
        .arrow:hover {
            transform: scale(1.2);
        }
        
        .direction-label {
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.9em;
            text-align: center;
            margin: 5px 0;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            margin: 15px 0;
            overflow-x: auto;
        }
        
        .proof-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Times New Roman', serif;
            font-size: 1.1em;
            margin: 15px 0;
        }
        
        .key-point {
            background: #fff3cd;
            border: 2px solid #ffeaa7;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            border-left: 8px solid #fdcb6e;
        }
        
        .example-section {
            margin: 40px 0;
            padding: 30px;
            background: #f1f2f6;
            border-radius: 15px;
        }
        
        .example-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .comparison-table th {
            background: #3498db;
            color: white;
            padding: 15px;
            text-align: left;
            font-size: 1.1em;
        }
        
        .comparison-table td {
            padding: 15px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .highlight {
            background: #fff3cd;
            padding: 3px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Recursion ↔ Strong Induction: The Duality</h1>
        
        <div class="key-point">
            <strong>Key Insight:</strong> Recursion and strong induction are <em>reverse forms</em> of each other - they use the same logical structure but in opposite directions!
        </div>
        
        <div class="duality-container">
            <div class="method-box recursion-box">
                <div class="method-title recursion-title">RECURSION</div>
                <p><strong>Direction:</strong> Large → Small</p>
                <p><strong>Mindset:</strong> "To solve this problem, first solve smaller subproblems"</p>
                <p><strong>Structure:</strong></p>
                <ul>
                    <li>Break current problem into smaller pieces</li>
                    <li>Recursively solve each piece</li>
                    <li>Combine results</li>
                </ul>
                <p><strong>Implementation approach</strong></p>
            </div>
            
            <div class="arrow-container">
                <div class="direction-label">TOP-DOWN</div>
                <div class="arrow">⇊</div>
                <div class="arrow">⇈</div>
                <div class="direction-label">BOTTOM-UP</div>
            </div>
            
            <div class="method-box induction-box">
                <div class="method-title induction-title">STRONG INDUCTION</div>
                <p><strong>Direction:</strong> Small → Large</p>
                <p><strong>Mindset:</strong> "If all smaller cases work, then this case works"</p>
                <p><strong>Structure:</strong></p>
                <ul>
                    <li>Assume smaller cases are true</li>
                    <li>Decompose current case</li>
                    <li>Apply assumptions to prove current case</li>
                </ul>
                <p><strong>Proof approach</strong></p>
            </div>
        </div>
        
        <div class="example-section">
            <div class="example-title">Tree Edges Example: Both Perspectives</div>
            
            <div class="duality-container">
                <div class="method-box recursion-box">
                    <h3>Recursive Algorithm</h3>
                    <div class="code-block">
function countEdges(tree):
    if tree.size == 1:
        return 0
    else:
        subtrees = decompose(tree)
        total = 0
        for each subtree in subtrees:
            total += countEdges(subtree)
        return total + num_connections
                    </div>
                    <p><span class="highlight">Top-down:</span> Break into subtrees, recursively count their edges</p>
                </div>
                
                <div class="arrow-container">
                    <div class="arrow">↔</div>
                    <div style="font-size: 0.8em; text-align: center; margin-top: 5px;">Same Logic!</div>
                </div>
                
                <div class="method-box induction-box">
                    <h3>Strong Induction Proof</h3>
                    <div class="proof-block">
Assume: All trees with < n nodes 
        satisfy |E| = |V| - 1

Prove: Tree T with n nodes 
       satisfies |E| = |V| - 1

Method: Decompose T into subtrees,
        apply assumption to each,
        combine results
                    </div>
                    <p><span class="highlight">Bottom-up:</span> Assume subtrees work, prove main tree works</p>
                </div>
            </div>
        </div>
        
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Aspect</th>
                    <th>Recursion</th>
                    <th>Strong Induction</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Purpose</strong></td>
                    <td>Solve problems computationally</td>
                    <td>Prove mathematical statements</td>
                </tr>
                <tr>
                    <td><strong>Direction</strong></td>
                    <td>Top-down (large → small)</td>
                    <td>Bottom-up (small → large)</td>
                </tr>
                <tr>
                    <td><strong>Base Case</strong></td>
                    <td>Stopping condition</td>
                    <td>Starting point of proof</td>
                </tr>
                <tr>
                    <td><strong>Decomposition</strong></td>
                    <td>"How do I break this down?"</td>
                    <td>"How did this build up?"</td>
                </tr>
                <tr>
                    <td><strong>Trust</strong></td>
                    <td>Trust that recursive calls work</td>
                    <td>Trust that smaller cases are proven</td>
                </tr>
                <tr>
                    <td><strong>Result</strong></td>
                    <td>Algorithm that computes answer</td>
                    <td>Proof that formula is correct</td>
                </tr>
            </tbody>
        </table>
        
        <div class="key-point">
            <h3>The Deep Connection</h3>
            <p>Every recursive algorithm corresponds to a strong induction proof of its correctness, and every strong induction proof corresponds to a natural recursive solution!</p>
            <ul>
                <li><strong>Recursion proves the algorithm terminates and works</strong></li>
                <li><strong>Strong induction proves why the recursive structure is mathematically sound</strong></li>
                <li><strong>Both use identical decomposition strategies</strong></li>
                <li><strong>Both handle multiple subproblems of varying sizes</strong></li>
            </ul>
        </div>
        
        <div class="example-section">
            <div class="example-title">ตัวอย่าง B: ต้นไม้ไบนารีสมบูรณ์แบบ | Example B: Perfect Binary Tree</div>
            
            <div style="background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; padding: 20px; border-radius: 15px; margin: 15px 0; font-size: 1.2em; font-weight: 500;">
                <strong>Theorem | ทฤษฎีบท:</strong> A perfect binary tree of height h has exactly N(h) = 2^(h+1) - 1 nodes.<br>
                <span style="font-size: 0.9em; opacity: 0.9;">ต้นไม้ไบนารีสมบูรณ์แบบของความสูง h มีโหนดจำนวน N(h) = 2^(h+1) - 1 โหนดพอดี</span>
            </div>

            <div style="background: #fff3cd; border: 2px solid #ffeaa7; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <strong>Definition | คำนิยาม:</strong><br>
                <span style="color: #8e44ad;">ต้นไม้ไบนารีสมบูรณ์แบบของความสูง h มีใบทั้งหมดอยู่ที่ระดับความลึก h และโหนดภายในทุกตัวมีลูกสองตัว</span><br>
                <span style="color: #2c3e50; font-style: italic;">A perfect binary tree of height h has all leaves at depth h and every internal node has two children.</span>
            </div>

            <h4 style="color: #27ae60; margin: 20px 0 10px 0;">การพิสูจน์โดยการพิสูจน์เหนี่ยวนำตามความสูง | Proof by Induction on Height</h4>

            <div style="background: #e8f6f3; border-left: 4px solid #1abc9c; padding: 15px; margin: 15px 0; border-radius: 4px;">
                <div style="color: #16a085; font-weight: bold; margin-bottom: 8px;">ขั้นตอนที่ 1: กรณีพื้นฐาน | Step 1: Base Case</div>
                <p><strong>h = 0:</strong> A perfect binary tree of height 0 is just a single leaf node.</p>
                <p><span style="color: #8e44ad;">ต้นไม้ไบนารีสมบูรณ์แบบของความสูง 0 เป็นเพียงโหนดใบเดียว</span></p>
                <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 10px 0;">
                    N(0) = 1<br>
                    2^(0+1) - 1 = 2¹ - 1 = 2 - 1 = 1 ✓
                </div>
                <p>Base case holds! | กรณีพื้นฐานเป็นจริง!</p>
            </div>

            <div style="background: #e8f6f3; border-left: 4px solid #1abc9c; padding: 15px; margin: 15px 0; border-radius: 4px;">
                <div style="color: #16a085; font-weight: bold; margin-bottom: 8px;">ขั้นตอนที่ 2: สมมติฐานการเหนี่ยวนำ | Step 2: Inductive Hypothesis</div>
                <p><strong>Assume:</strong> For some k ≥ 0, N(k) = 2^(k+1) - 1</p>
                <p><span style="color: #8e44ad;">สมมติ: สำหรับ k ≥ 0 บางค่า, N(k) = 2^(k+1) - 1</span></p>
                <p style="font-style: italic;">That is, the formula holds for perfect binary trees of height k.</p>
            </div>

            <div style="background: #e8f6f3; border-left: 4px solid #1abc9c; padding: 15px; margin: 15px 0; border-radius: 4px;">
                <div style="color: #16a085; font-weight: bold; margin-bottom: 8px;">ขั้นตอนที่ 3: ขั้นตอนการเหนี่ยวนำ | Step 3: Inductive Step</div>
                <p><strong>Goal:</strong> Prove N(k+1) = 2^(k+2) - 1</p>
                <p><span style="color: #8e44ad;">เป้าหมาย: พิสูจน์ N(k+1) = 2^(k+2) - 1</span></p>
                
                <p><strong>Structure Analysis | การวิเคราะห์โครงสร้าง:</strong></p>
                <p>A perfect binary tree of height k+1 consists of:</p>
                <ul style="margin-left: 20px;">
                    <li>1 root node | 1 โหนดราก</li>
                    <li>2 perfect subtrees of height k | 2 ต้นไม้ย่อยสมบูรณ์แบบของความสูง k</li>
                </ul>

                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0; text-align: left;">
                    <div style="font-family: monospace; margin: 8px 0; font-size: 1.05em;">N(k+1) = 1 + 2·N(k)</div>
                    <div style="font-family: monospace; margin: 8px 0; font-size: 1.05em;">       = 1 + 2·(2^(k+1) - 1)  <span style="color: #666; font-family: sans-serif;">[by inductive hypothesis]</span></div>
                    <div style="font-family: monospace; margin: 8px 0; font-size: 1.05em;">       = 1 + 2·2^(k+1) - 2·1</div>
                    <div style="font-family: monospace; margin: 8px 0; font-size: 1.05em;">       = 1 + 2^(k+2) - 2</div>
                    <div style="font-family: monospace; margin: 8px 0; font-size: 1.05em;">       = 2^(k+2) - 1 ✓</div>
                </div>
                <p>The inductive step holds! | ขั้นตอนการเหนี่ยวนำเป็นจริง!</p>
            </div>

            <div style="background: linear-gradient(135deg, #00b894, #00a085); color: white; padding: 20px; border-radius: 15px; margin: 15px 0; font-size: 1.3em; font-weight: 600;">
                ✓ By induction, N(h) = 2^(h+1) - 1 for all h ≥ 0<br>
                <span style="font-size: 0.8em;">ด้วยการเหนี่ยวนำ, N(h) = 2^(h+1) - 1 สำหรับทุก h ≥ 0</span>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                <div>
                    <h4>ตัวอย่างการคำนวณ | Example Calculations</h4>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 8px; font-size: 0.9em;">
h=0: N(0) = 2¹ - 1 = 1
h=1: N(1) = 2² - 1 = 3  
h=2: N(2) = 2³ - 1 = 7
h=3: N(3) = 2⁴ - 1 = 15
                    </div>
                </div>
                <div>
                    <h4>Visual Verification | การตรวจสอบด้วยภาพ</h4>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 8px; font-size: 0.85em;">
Height 0:    •           (1 node)

Height 1:    •           (3 nodes)
            / \
           •   •

Height 2:    •           (7 nodes)  
           / \
          •   •
         / \ / \
        •  • •  •
                    </div>
                </div>
            </div>
        </div>

        <div class="example-section">
            <div class="example-title">ตัวอย่าง C: ความยาวการสำรวจ (แสดงทั้งสองมุมมอง) | Example C: Traversal Lengths (Both Perspectives)</div>
            
            <div style="background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; padding: 20px; border-radius: 15px; margin: 15px 0; font-size: 1.2em; font-weight: 500;">
                <strong>Theorem | ทฤษฎีบท:</strong> For any binary tree T: |preorder| = |inorder| = |postorder| = size(T)<br>
                <span style="font-size: 0.9em; opacity: 0.9;">สำหรับต้นไม้ไบนารี T ใดๆ: |preorder| = |inorder| = |postorder| = size(T)</span>
            </div>

            <div style="background: #fff3cd; border: 2px solid #ffeaa7; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <strong>Concrete Example Tree | ตัวอย่างต้นไม้จริง:</strong><br>
                <div style="font-family: monospace; background: #f8f9fa; padding: 12px; border-radius: 6px; margin: 10px 0; font-size: 0.9em; text-align: center;">
    1
   / \
  2   3
 / \
4   5

Size = 5 nodes | ขนาด = 5 โหนด
                </div>
            </div>

            <h4 style="color: #e74c3c; margin: 20px 0 15px 0; font-size: 1.4em;">🔄 Preorder Traversal | การสำรวจ Preorder</h4>

            <div style="display: grid; grid-template-columns: 1fr 100px 1fr; gap: 20px; margin: 20px 0; align-items: center;">
                <div style="background: #fdcbf1; padding: 20px; border-radius: 15px; border-left: 8px solid #e74c3c; min-height: 300px;">
                    <h4 style="color: #c0392b; margin-bottom: 15px;">Recursive Algorithm | อัลกอริทึมเรียกซ้ำ</h4>
                    <p style="margin-bottom: 15px;"><strong>Top-down:</strong> Build result by visiting root first</p>
                    <p style="margin-bottom: 15px; font-style: italic; color: #8e44ad;">จากบนลงล่าง: สร้างผลลัพธ์โดยเยือนรากก่อน</p>
                    
                    <div style="background: #2c3e50; color: #ecf0f1; padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; margin: 10px 0; font-size: 0.8em;">
def preorder(T):
    if T is None:
        return []
    else:
        return ([T.key] + 
                preorder(T.left) + 
                preorder(T.right))
                    </div>
                    
                    <p><strong>การคำนวณ | Calculation:</strong></p>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.8em;">
preorder(1) = [1] + preorder(2) + preorder(3)
preorder(2) = [2] + [4] + [5] = [2,4,5]  
preorder(3) = [3]
Result: [1,2,4,5,3] | Length = 5
                    </div>
                </div>
                
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <div style="font-size: 2.5em; color: #3498db; margin: 10px 0;">↔</div>
                    <div style="font-weight: bold; color: #2c3e50; font-size: 0.8em; text-align: center;">Same Logic!</div>
                </div>
                
                <div style="background: #d1f2eb; padding: 20px; border-radius: 15px; border-left: 8px solid #27ae60; min-height: 300px;">
                    <h4 style="color: #27ae60; margin-bottom: 15px;">Strong Induction Proof | การพิสูจน์เหนี่ยวนำแกนแข็ง</h4>
                    <p style="margin-bottom: 15px;"><strong>Bottom-up:</strong> Assume subtrees work, prove whole works</p>
                    <p style="margin-bottom: 15px; font-style: italic; color: #8e44ad;">จากล่างขึ้นบน: สมมติว่าต้นไม้ย่อยทำงาน พิสูจน์ว่าทั้งต้นทำงาน</p>
                    
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin: 10px 0; font-size: 0.85em;">
                        <strong>IH:</strong> |preorder(L)| = size(L), |preorder(R)| = size(R)
                        <br><br>
                        <strong>Proof:</strong><br>
                        |preorder(T)| = |[key]| + |preorder(L)| + |preorder(R)|<br>
                        = 1 + size(L) + size(R) = size(T) ✓
                    </div>
                    
                    <p><strong>การตรวจสอบ | Verification:</strong></p>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.8em;">
|preorder(1)| = 1 + |preorder(2)| + |preorder(3)|
                = 1 + 3 + 1 = 5 = size(1) ✓
                    </div>
                </div>
            </div>

            <h4 style="color: #e74c3c; margin: 20px 0 15px 0; font-size: 1.4em;">🔄 Inorder Traversal | การสำรวจ Inorder</h4>

            <div style="display: grid; grid-template-columns: 1fr 100px 1fr; gap: 20px; margin: 20px 0; align-items: center;">
                <div style="background: #fdcbf1; padding: 20px; border-radius: 15px; border-left: 8px solid #e74c3c; min-height: 300px;">
                    <h4 style="color: #c0392b; margin-bottom: 15px;">Recursive Algorithm | อัลกอริทึมเรียกซ้ำ</h4>
                    <p style="margin-bottom: 15px;"><strong>Top-down:</strong> Visit left, root, then right</p>
                    <p style="margin-bottom: 15px; font-style: italic; color: #8e44ad;">จากบนลงล่าง: เยือนซ้าย ราก แล้วขวา</p>
                    
                    <div style="background: #2c3e50; color: #ecf0f1; padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; margin: 10px 0; font-size: 0.8em;">
def inorder(T):
    if T is None:
        return []
    else:
        return (inorder(T.left) + 
                [T.key] + 
                inorder(T.right))
                    </div>
                    
                    <p><strong>การคำนวณ | Calculation:</strong></p>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.8em;">
inorder(1) = inorder(2) + [1] + inorder(3)
inorder(2) = [4] + [2] + [5] = [4,2,5]
inorder(3) = [3]  
Result: [4,2,5,1,3] | Length = 5
                    </div>
                </div>
                
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <div style="font-size: 2.5em; color: #3498db; margin: 10px 0;">↔</div>
                    <div style="font-weight: bold; color: #2c3e50; font-size: 0.8em; text-align: center;">Same Logic!</div>
                </div>
                
                <div style="background: #d1f2eb; padding: 20px; border-radius: 15px; border-left: 8px solid #27ae60; min-height: 300px;">
                    <h4 style="color: #27ae60; margin-bottom: 15px;">Strong Induction Proof | การพิสูจน์เหนี่ยวนำแกนแข็ง</h4>
                    <p style="margin-bottom: 15px;"><strong>Bottom-up:</strong> Assume subtrees work, prove whole works</p>
                    <p style="margin-bottom: 15px; font-style: italic; color: #8e44ad;">จากล่างขึ้นบน: สมมติว่าต้นไม้ย่อยทำงาน พิสูจน์ว่าทั้งต้นทำงาน</p>
                    
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin: 10px 0; font-size: 0.85em;">
                        <strong>IH:</strong> |inorder(L)| = size(L), |inorder(R)| = size(R)
                        <br><br>
                        <strong>Proof:</strong><br>
                        |inorder(T)| = |inorder(L)| + |[key]| + |inorder(R)|<br>
                        = size(L) + 1 + size(R) = size(T) ✓
                    </div>
                    
                    <p><strong>การตรวจสอบ | Verification:</strong></p>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.8em;">
|inorder(1)| = |inorder(2)| + 1 + |inorder(3)|
              = 3 + 1 + 1 = 5 = size(1) ✓
                    </div>
                </div>
            </div>

            <h4 style="color: #e74c3c; margin: 20px 0 15px 0; font-size: 1.4em;">🔄 Postorder Traversal | การสำรวจ Postorder</h4>

            <div style="display: grid; grid-template-columns: 1fr 100px 1fr; gap: 20px; margin: 20px 0; align-items: center;">
                <div style="background: #fdcbf1; padding: 20px; border-radius: 15px; border-left: 8px solid #e74c3c; min-height: 300px;">
                    <h4 style="color: #c0392b; margin-bottom: 15px;">Recursive Algorithm | อัลกอริทึมเรียกซ้ำ</h4>
                    <p style="margin-bottom: 15px;"><strong>Top-down:</strong> Visit children before root</p>
                    <p style="margin-bottom: 15px; font-style: italic; color: #8e44ad;">จากบนลงล่าง: เยือนลูกก่อนราก</p>
                    
                    <div style="background: #2c3e50; color: #ecf0f1; padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; margin: 10px 0; font-size: 0.8em;">
def postorder(T):
    if T is None:
        return []
    else:
        return (postorder(T.left) + 
                postorder(T.right) +
                [T.key])
                    </div>
                    
                    <p><strong>การคำนวณ | Calculation:</strong></p>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.8em;">
postorder(1) = postorder(2) + postorder(3) + [1]
postorder(2) = [4] + [5] + [2] = [4,5,2]
postorder(3) = [3]
Result: [4,5,2,3,1] | Length = 5
                    </div>
                </div>
                
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <div style="font-size: 2.5em; color: #3498db; margin: 10px 0;">↔</div>
                    <div style="font-weight: bold; color: #2c3e50; font-size: 0.8em; text-align: center;">Same Logic!</div>
                </div>
                
                <div style="background: #d1f2eb; padding: 20px; border-radius: 15px; border-left: 8px solid #27ae60; min-height: 300px;">
                    <h4 style="color: #27ae60; margin-bottom: 15px;">Strong Induction Proof | การพิสูจน์เหนี่ยวนำแกนแข็ง</h4>
                    <p style="margin-bottom: 15px;"><strong>Bottom-up:</strong> Assume subtrees work, prove whole works</p>
                    <p style="margin-bottom: 15px; font-style: italic; color: #8e44ad;">จากล่างขึ้นบน: สมมติว่าต้นไม้ย่อยทำงาน พิสูจน์ว่าทั้งต้นทำงาน</p>
                    
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin: 10px 0; font-size: 0.85em;">
                        <strong>IH:</strong> |postorder(L)| = size(L), |postorder(R)| = size(R)
                        <br><br>
                        <strong>Proof:</strong><br>
                        |postorder(T)| = |postorder(L)| + |postorder(R)| + |[key]|<br>
                        = size(L) + size(R) + 1 = size(T) ✓
                    </div>
                    
                    <p><strong>การตรวจสอบ | Verification:</strong></p>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.8em;">
|postorder(1)| = |postorder(2)| + |postorder(3)| + 1
                = 3 + 1 + 1 = 5 = size(1) ✓
                    </div>
                </div>
            </div>

            <div style="background: linear-gradient(45deg, #3498db, #9b59b6); color: white; padding: 20px; border-radius: 10px; margin: 20px 0; text-align: center;">
                <h4 style="margin-bottom: 15px; font-size: 1.3em;">🎯 The Deep Connection | ความเชื่อมโยงลึกซึ้ง</h4>
                <p style="margin-bottom: 10px; font-size: 1.1em;">Each recursive algorithm has an identical strong induction proof!</p>
                <p style="margin-bottom: 10px; font-style: italic; color: #ecf0f1;">อัลกอริทึมเรียกซ้ำแต่ละตัวมีการพิสูจน์เหนี่ยวนำแกนแข็งที่เหมือนกัน!</p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                        <strong>Algorithm:</strong> Break into subproblems, solve recursively, combine<br>
                        <em>อัลกอริทึม: แบ่งเป็นปัญหาย่อย แก้เรียกซ้ำ รวมผล</em>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                        <strong>Induction:</strong> Assume subproblems work, prove combination works<br>
                        <em>เหนี่ยวนำ: สมมติปัญหาย่อยทำงาน พิสูจน์การรวมทำงาน</em>
                    </div>
                </div>
            </div>

            <div style="background: #f8f9fa; padding: 20px; border-radius: 15px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-bottom: 15px; text-align: center;">📊 Complete Verification | การตรวจสอบครบถ้วน</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; text-align: center;">
                    <div>
                        <h5 style="color: #e74c3c; margin-bottom: 10px;">Preorder</h5>
                        <div style="font-family: monospace; background: #fff; padding: 10px; border-radius: 4px; font-size: 0.85em;">
[1, 2, 4, 5, 3]<br>
Length = 5 ✓
                        </div>
                    </div>
                    <div>
                        <h5 style="color: #e74c3c; margin-bottom: 10px;">Inorder</h5>
                        <div style="font-family: monospace; background: #fff; padding: 10px; border-radius: 4px; font-size: 0.85em;">
[4, 2, 5, 1, 3]<br>
Length = 5 ✓
                        </div>
                    </div>
                    <div>
                        <h5 style="color: #e74c3c; margin-bottom: 10px;">Postorder</h5>
                        <div style="font-family: monospace; background: #fff; padding: 10px; border-radius: 4px; font-size: 0.85em;">
[4, 5, 2, 3, 1]<br>
Length = 5 ✓
                        </div>
                    </div>
                </div>
                <p style="text-align: center; margin-top: 15px; font-weight: bold; color: #27ae60;">
                    All traversals visit each node exactly once → Length equals tree size<br>
                    <span style="color: #8e44ad; font-style: italic;">การสำรวจทุกแบบเยือนแต่ละโหนดพอดีครั้งเดียว → ความยาวเท่ากับขนาดต้นไม้</span>
                </p>
            </div>
        </div>

        <div class="example-section">
            <div class="example-title">ตัวอย่าง D: คุณสมบัติ Inorder ของ BST | Example D: BST Inorder Property</div>
            
            <div style="background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; padding: 20px; border-radius: 15px; margin: 15px 0; font-size: 1.2em; font-weight: 500;">
                <strong>Theorem | ทฤษฎีบท:</strong> For any BST T, inorder(T) is a strictly increasing sequence.<br>
                <span style="font-size: 0.9em; opacity: 0.9;">สำหรับ BST T ใดๆ, inorder(T) เป็นลำดับที่เพิ่มขึ้นอย่างเคร่งครัด</span>
            </div>

            <div style="background: #fff3cd; border: 2px solid #ffeaa7; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <strong>Important Terminology | คำศัพท์สำคัญ:</strong><br>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 10px 0;">
                    <div>
                        <strong style="color: #e74c3c;">Root</strong> = โหนดตำแหน่งบนสุด | The topmost node position<br>
                        <strong style="color: #e74c3c;">Key</strong> = ข้อมูลที่เก็บในโหนด | The data/value stored in a node
                    </div>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 8px; border-radius: 4px; font-size: 0.8em;">
Node = {position, key}<br>
key(root) = value at root<br>
key(T) = key at node T
                    </div>
                </div>
            </div>

            <div style="background: #fff3cd; border: 2px solid #ffeaa7; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <strong>BST Invariant | ความไม่แปรเปลี่ยนของ BST:</strong><br>
                <span style="color: #8e44ad;">สำหรับ BST ที่มีกุญแจที่แตกต่างกัน: กุญแจทั้งหมดในต้นไม้ย่อยซ้าย < key(T) < กุญแจทั้งหมดในต้นไม้ย่อยขวา</span><br>
                <span style="color: #2c3e50; font-style: italic;">For BST with distinct keys: all keys in left subtree < key(T) < all keys in right subtree</span>
                <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 10px 0; text-align: center; font-family: 'Times New Roman', serif; font-size: 1.1em;">
                    ∀x ∈ left subtree: x < key(T)<br>
                    ∀y ∈ right subtree: y > key(T)
                </div>
                <p style="margin: 8px 0; font-size: 0.9em; color: #666;">
                    <strong>Note:</strong> key(T) means "the key stored at node T" | หมายถึง "กุญแจที่เก็บไว้ที่โหนด T"
                </p>
            </div>

            <h4 style="color: #27ae60; margin: 20px 0 10px 0;">การพิสูจน์โดยการพิสูจน์เหนี่ยวนำเชิงโครงสร้าง | Proof by Structural Induction</h4>

            <div style="background: #e8f6f3; border-left: 4px solid #1abc9c; padding: 15px; margin: 15px 0; border-radius: 4px;">
                <div style="color: #16a085; font-weight: bold; margin-bottom: 8px;">ขั้นตอนที่ 1: กรณีพื้นฐาน | Step 1: Base Cases</div>
                
                <p><strong>Case 1 - Empty Tree | กรณี 1 - ต้นไม้ว่าง:</strong> T = ∅</p>
                <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 10px 0;">
                    inorder(∅) = []<br>
                    Empty sequence is trivially sorted ✓
                </div>

                <p><strong>Case 2 - Single Node | กรณี 2 - โหนดเดียว:</strong> T = Node(key, ∅, ∅)</p>
                <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 10px 0;">
                    inorder(T) = [] ++ [key] ++ [] = [key]<br>
                    Single element sequence is trivially sorted ✓
                </div>
                <p>Base cases hold! | กรณีพื้นฐานเป็นจริง!</p>
            </div>

            <div style="background: #e8f6f3; border-left: 4px solid #1abc9c; padding: 15px; margin: 15px 0; border-radius: 4px;">
                <div style="color: #16a085; font-weight: bold; margin-bottom: 8px;">ขั้นตอนที่ 2: สมมติฐานการเหนี่ยวนำ | Step 2: Inductive Hypothesis</div>
                <p><strong>Assume:</strong> For all BST subtrees L and R with size < size(T):</p>
                <p><span style="color: #8e44ad;">สมมติ: สำหรับต้นไม้ย่อย BST ทุกต้น L และ R ที่มีขนาด < size(T):</span></p>
                <div style="background: #f8f9fa; padding: 12px; border-radius: 4px; margin: 10px 0;">
                    <div style="font-family: 'Times New Roman', serif; font-size: 1.1em; text-align: center; margin-bottom: 8px;">
                        inorder(L) and inorder(R) are strictly increasing
                    </div>
                    <p style="margin: 0; font-size: 0.9em; text-align: center; font-style: italic;">
                        inorder(L) และ inorder(R) เพิ่มขึ้นอย่างเคร่งครัด
                    </p>
                </div>
            </div>

            <div style="background: #e8f6f3; border-left: 4px solid #1abc9c; padding: 15px; margin: 15px 0; border-radius: 4px;">
                <div style="color: #16a085; font-weight: bold; margin-bottom: 8px;">ขั้นตอนที่ 3: ขั้นตอนการเหนี่ยวนำ | Step 3: Inductive Step</div>
                <p><strong>Goal:</strong> Prove inorder(T) is sorted for T = Node(key, L, R)</p>
                <p><span style="color: #8e44ad;">เป้าหมาย: พิสูจน์ว่า inorder(T) เรียงลำดับสำหรับ T = Node(key, L, R)</span></p>
                
                <p><strong>Structure Analysis | การวิเคราะห์โครงสร้าง:</strong></p>
                <div style="font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 10px 0;">
                    inorder(T) = inorder(L) ++ [key] ++ inorder(R)
                </div>

                <p><strong>Sortedness Proof | การพิสูจน์การเรียงลำดับ:</strong></p>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0; text-align: left;">
                    <p style="margin: 8px 0;"><strong>1.</strong> By IH: inorder(L) and inorder(R) are sorted</p>
                    <p style="margin: 8px 0; font-style: italic; color: #666;">โดย IH: inorder(L) และ inorder(R) เรียงลำดับแล้ว</p>
                    
                    <p style="margin: 8px 0;"><strong>2.</strong> By BST invariant:</p>
                    <div style="font-family: monospace; margin: 8px 0; background: #e9ecef; padding: 8px; border-radius: 4px;">
                        ∀x ∈ inorder(L): x < key
                        ∀y ∈ inorder(R): y > key
                    </div>
                    
                    <p style="margin: 8px 0;"><strong>3.</strong> Therefore: max(inorder(L)) < key < min(inorder(R))</p>
                    <p style="margin: 8px 0; font-style: italic; color: #666;">ดังนั้น: max(inorder(L)) < key < min(inorder(R))</p>
                    
                    <p style="margin: 8px 0;"><strong>4.</strong> Concatenation preserves sorting:</p>
                    <div style="font-family: monospace; margin: 8px 0; background: #e9ecef; padding: 8px; border-radius: 4px;">
                        inorder(L) ++ [key] ++ inorder(R) is strictly increasing ✓
                    </div>
                </div>
            </div>

            <div style="background: linear-gradient(135deg, #00b894, #00a085); color: white; padding: 20px; border-radius: 15px; margin: 15px 0; font-size: 1.3em; font-weight: 600;">
                ✓ By structural induction, inorder(T) is sorted for all BST T<br>
                <span style="font-size: 0.8em;">ด้วยการเหนี่ยวนำเชิงโครงสร้าง, inorder(T) เรียงลำดับสำหรับ BST T ทุกต้น</span>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                <div>
                    <h4>ตัวอย่าง BST พร้อมคำอธิบาย | BST Example with Clarification</h4>
                    <div style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 8px; font-size: 0.85em;">
BST:         5  ← root node, key(root) = 5
           /   \
          3     8  ← internal nodes  
         / \   / \
        1   4 7   9  ← leaf nodes

<strong style="color: #e74c3c;">For root node (position = root, key = 5):</strong>
Left subtree keys: {1, 3, 4} < 5 ✓
Right subtree keys: {7, 8, 9} > 5 ✓

<strong style="color: #e74c3c;">For node with key = 3:</strong>  
Left subtree keys: {1} < 3 ✓
Right subtree keys: {4} > 3 ✓

inorder(BST) = [1, 3, 4, 5, 7, 8, 9] ✓ Sorted!
                    </div>
                    <p style="font-size: 0.9em; margin-top: 10px;">
                        <strong>กุญแจ | Key insight:</strong> key(T) หมายถึง "ค่าที่เก็บไว้ที่โหนด T" ไม่ใช่ตำแหน่งโหนด<br>
                        key(T) means "value stored at node T", not the node position itself
                    </p>
                </div>
                <div>
                    <h4>Why BST Invariant Works for Inorder | ทำไม BST Invariant ใช้ได้กับ Inorder</h4>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; font-size: 0.9em;">
                        <p style="margin-bottom: 12px;"><strong>Inorder pattern | รูปแบบ Inorder:</strong></p>
                        <div style="font-family: monospace; background: #e9ecef; padding: 8px; border-radius: 4px; margin: 8px 0; font-size: 0.85em;">
inorder(T) = inorder(left) + [key(T)] + inorder(right)
                        </div>
                        
                        <p style="margin-bottom: 8px; margin-top: 15px;"><strong>BST guarantee | การรับประกันของ BST:</strong></p>
                        <p style="margin-bottom: 6px; font-size: 0.85em;">• All values in inorder(left) < key(T)</p>
                        <p style="margin-bottom: 6px; font-size: 0.85em; color: #8e44ad;">• ค่าทั้งหมดใน inorder(left) < key(T)</p>
                        <p style="margin-bottom: 6px; font-size: 0.85em;">• All values in inorder(right) > key(T)</p>
                        <p style="margin-bottom: 6px; font-size: 0.85em; color: #8e44ad;">• ค่าทั้งหมดใน inorder(right) > key(T)</p>
                        
                        <p style="margin-top: 15px; margin-bottom: 8px;"><strong>Result | ผลลัพธ์:</strong></p>
                        <p style="margin-bottom: 0; font-size: 0.85em;">Concatenation preserves sorted order!</p>
                        <p style="margin-bottom: 0; font-size: 0.85em; color: #8e44ad;">การเชื่อมต่อรักษาลำดับการเรียง!</p>
                    </div>
                </div>
            </div>

            <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #2196f3;">
                <strong>Application | การประยุกต์:</strong> This theorem explains why inorder traversal is used for sorted enumeration of BST contents.<br>
                <span style="color: #8e44ad;">ทฤษฎีบทนี้อธิบายว่าทำไมการสำรวจ inorder จึงใช้สำหรับการแจกแจงเนื้อหา BST ตามลำดับ</span><br><br>
                <strong>Corollary | บทสรุป:</strong> BST search, insert, and delete operations preserve this property.<br>
                <span style="color: #8e44ad;">การค้นหา การแทรก และการลบใน BST รักษาคุณสมบัตินี้ไว้</span>
            </div>
        </div>

        <div class="example-section">
            <div class="example-title">Why "Strong" for Both? | ทำไม "แกนแข็ง" สำหรับทั้งสอง?</div>
            <p><span style="color: #8e44ad;">ทั้งการเรียกซ้ำและการพิสูจน์เหนี่ยวนำเป็น "แกนแข็ง" เพราะจัดการได้:</span></p>
            <p><span style="color: #2c3e50; font-style: italic;">Both recursion and strong induction are "strong" because they can handle:</span></p>
            <ul style="font-size: 1.1em;">
                <li><strong>ปัญหาย่อยหลายตัว | Multiple subproblems</strong> (ไม่ใช่แค่กรณีเล็กกว่าหนึ่งเดียว | not just one smaller case)</li>
                <li><strong>ปัญหาย่อยของขนาดต่างกัน | Subproblems of different sizes</strong> (ไม่ใช่แค่ขนาด n-1 | not just size n-1)</li>
                <li><strong>การแยกส่วนที่ยืดหยุ่น | Flexible decomposition</strong> (หลายวิธีในการแบ่งปัญหา | many ways to break down the problem)</li>
            </ul>
            <p><span style="color: #8e44ad;">ความยืดหยุ่นนี้ทำให้เหมาะสำหรับปัญหาต้นไม้ อัลกอริทึมแบ่งแยกและพิชิต และโครงสร้างเรียกซ้ำที่ซับซ้อน!</span></p>
            <p style="font-style: italic;">This flexibility makes them perfect for tree problems, divide-and-conquer algorithms, and complex recursive structures!</p>
        </div>
    </div>
</body>
</html>