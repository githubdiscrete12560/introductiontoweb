<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Transformations | การแปลงเมทริกซ์</title>
    
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true,
                macros: {
                    'R': ['\\mathbf{R}', 0],
                    'T': ['\\mathbf{T}', 0], 
                    'S': ['\\mathbf{S}', 0],
                    'M': ['\\mathbf{M}', 0],
                    'I': ['\\mathbf{I}', 0],
                    'v': ['\\mathbf{v}', 0],
                    'x': ['\\mathbf{x}', 0],
                    'y': ['\\mathbf{y}', 0],
                    'bmat': ['\\begin{bmatrix}#1\\end{bmatrix}', 1]
                }
            },
            chtml: {
                scale: 1.1,
                minScale: 0.5
            }
        };
    </script>
    
    <script async src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
            transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        
        .slide {
            min-width: 100vw;
            padding: 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        
        .bilingual-title {
            margin-bottom: 30px;
        }
        
        .english {
            font-size: 3em;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.4);
            margin-bottom: 10px;
        }
        
        .thai {
            font-size: 2.2em;
            color: #87ceeb;
            font-style: italic;
            font-weight: 500;
        }
        
        .content {
            max-width: 1100px;
            width: 100%;
        }
        
        .dual-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin: 30px 0;
            align-items: start;
        }
        
        .section {
            background: rgba(255,255,255,0.1);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .math-box {
            background: rgba(0,0,0,0.4);
            padding: 25px;
            margin: 20px 0;
            border-radius: 12px;
            border-left: 5px solid #ffd700;
            text-align: center;
        }
        
        .interactive-demo {
            background: rgba(255,255,255,0.15);
            padding: 30px;
            border-radius: 15px;
            margin: 25px 0;
            position: relative;
            overflow: hidden;
        }
        
        .interactive-demo::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, rgba(255,215,0,0.1), rgba(135,206,235,0.1));
            z-index: -1;
        }
        
        .canvas-container {
            background: rgba(255,255,255,0.95);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            color: black;
        }
        
        canvas {
            border: 2px solid #3498db;
            border-radius: 8px;
            background: white;
            display: block;
            margin: 0 auto;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin: 15px 0;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0,0,0,0.1);
            padding: 8px 12px;
            border-radius: 20px;
        }
        
        .control-group label {
            font-weight: bold;
            min-width: 60px;
        }
        
        .control-group input[type="range"] {
            width: 120px;
            accent-color: #3498db;
        }
        
        .control-group .value-display {
            background: #3498db;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            min-width: 50px;
            text-align: center;
            font-size: 0.9em;
        }
        
        .question-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1));
            border: 2px solid rgba(255,215,0,0.3);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
        }
        
        .question-card:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
            border-color: #ffd700;
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .question-number {
            background: #ffd700;
            color: #333;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
        }
        
        .expand-icon {
            font-size: 1.5em;
            transition: transform 0.3s ease;
        }
        
        .question-card.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .answer {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: rgba(0,255,0,0.1);
            border-radius: 10px;
            border-left: 4px solid #00ff88;
            animation: slideDown 0.5s ease;
        }
        
        @keyframes slideDown {
            from { 
                opacity: 0; 
                transform: translateY(-20px);
                max-height: 0;
            }
            to { 
                opacity: 1; 
                transform: translateY(0);
                max-height: 500px;
            }
        }
        
        .navigation {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 1000;
        }
        
        .nav-button {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #333;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .nav-button:hover:not(:disabled) {
            background: linear-gradient(135deg, #ffed4e, #ffd700);
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        
        .nav-button:disabled {
            background: linear-gradient(135deg, #666, #555);
            color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .slide-counter {
            position: fixed;
            top: 30px;
            right: 30px;
            background: rgba(0,0,0,0.6);
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 1.2em;
            font-weight: bold;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.1);
        }
        
        .highlight {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: bold;
        }
        
        .formula-showcase {
            background: linear-gradient(135deg, rgba(0,0,0,0.6), rgba(0,0,0,0.4));
            padding: 30px;
            border-radius: 15px;
            margin: 25px 0;
            border: 2px solid #3498db;
            position: relative;
        }
        
        .application-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .app-card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid;
            transition: transform 0.3s ease;
        }
        
        .app-card:hover {
            transform: translateY(-5px);
        }
        
        .app-card.graphics { border-left-color: #e74c3c; }
        .app-card.robotics { border-left-color: #3498db; }
        .app-card.games { border-left-color: #9b59b6; }
        .app-card.engineering { border-left-color: #f39c12; }
        
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: #ffd700;
            transition: width 0.3s ease;
            z-index: 1001;
        }
        
        @media (max-width: 768px) {
            .dual-column {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .english {
                font-size: 2.2em;
            }
            
            .thai {
                font-size: 1.8em;
            }
            
            .slide {
                padding: 20px;
            }
            
            .application-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progress-bar"></div>
    
    <div class="slide-counter">
        <span id="current-slide">1</span> / <span id="total-slides">8</span>
    </div>

    <div class="container" id="slide-container">
        <!-- Slide 1: Title -->
        <div class="slide">
            <div class="bilingual-title">
                <div class="english">Matrix as Container of Basis Vectors</div>
                <div class="thai">เมทริกซ์เป็นภาชนะของเวกเตอร์พื้นฐาน</div>
            </div>
            
            <div class="content">
                <div class="dual-column">
                    <div class="section">
                        <h3>🎯 English Concept</h3>
                        <p>A matrix is fundamentally a container that holds the transformed basis vectors of a coordinate system. Each column represents where the original unit vectors end up after transformation.</p>
                        
                        <div class="math-box">
                            $$\M = \bmat{| & | \\ \text{transformed } \hat{i} & \text{transformed } \hat{j} \\ | & |}$$
                        </div>
                    </div>
                    
                    <div class="section">
                        <h3>🎯 แนวคิดภาษาไทย</h3>
                        <p>เมทริกซ์เป็นภาชนะที่เก็บเวกเตอร์พื้นฐานที่ผ่านการแปลงแล้ว แต่ละคอลัมน์แสดงตำแหน่งใหม่ของเวกเตอร์หน่วยเดิมหลังจากการแปลง</p>
                        
                        <div class="math-box">
                            $$\M = \bmat{| & | \\ \hat{i} \text{ ใหม่} & \hat{j} \text{ ใหม่} \\ | & |}$$
                        </div>
                    </div>
                </div>
                
                <div class="interactive-demo">
                    <div class="bilingual-title">
                        <div class="english" style="font-size: 1.8em;">Interactive Basis Vector Visualization</div>
                        <div class="thai" style="font-size: 1.4em;">การแสดงเวกเตอร์พื้นฐานแบบโต้ตอบ</div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="basis-canvas" width="500" height="400"></canvas>
                        <div class="controls">
                            <div class="control-group">
                                <label>a:</label>
                                <input type="range" id="a-slider" min="-3" max="3" step="0.1" value="2">
                                <span class="value-display" id="a-value">2.0</span>
                            </div>
                            <div class="control-group">
                                <label>b:</label>
                                <input type="range" id="b-slider" min="-3" max="3" step="0.1" value="0">
                                <span class="value-display" id="b-value">0.0</span>
                            </div>
                            <div class="control-group">
                                <label>c:</label>
                                <input type="range" id="c-slider" min="-3" max="3" step="0.1" value="1">
                                <span class="value-display" id="c-value">1.0</span>
                            </div>
                            <div class="control-group">
                                <label>d:</label>
                                <input type="range" id="d-slider" min="-3" max="3" step="0.1" value="1">
                                <span class="value-display" id="d-value">1.0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 2: Concrete Example -->
        <div class="slide">
            <div class="bilingual-title">
                <div class="english">Concrete Matrix-Vector Example</div>
                <div class="thai">ตัวอย่างการคูณเมทริกซ์-เวกเตอร์</div>
            </div>
            
            <div class="content">
                <div class="formula-showcase">
                    <div class="bilingual-title">
                        <div class="english" style="font-size: 1.6em; margin-bottom: 20px;">Step-by-Step Calculation | การคำนวณทีละขั้นตอน</div>
                    </div>
                    
                    <div class="math-box">
                        $$\bmat{3 & 1 \\ 0 & 2} \bmat{2 \\ 1} = \bmat{3 \times 2 + 1 \times 1 \\ 0 \times 2 + 2 \times 1} = \bmat{7 \\ 2}$$
                    </div>
                    
                    <div class="dual-column">
                        <div class="section">
                            <h3>🔍 Linear Combination View</h3>
                            <p>The result is a <span class="highlight">linear combination</span> of the matrix columns:</p>
                            <div class="math-box">
                                $$2 \cdot \bmat{3 \\ 0} + 1 \cdot \bmat{1 \\ 2} = \bmat{7 \\ 2}$$
                            </div>
                        </div>
                        
                        <div class="section">
                            <h3>🔍 มุมมองการรวมเชิงเส้น</h3>
                            <p>ผลลัพธ์คือ<span class="highlight">การรวมเชิงเส้น</span>ของคอลัมน์เมทริกซ์:</p>
                            <div class="math-box">
                                $$2 \cdot \bmat{3 \\ 0} + 1 \cdot \bmat{1 \\ 2} = \bmat{7 \\ 2}$$
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="interactive-demo">
                    <div class="canvas-container">
                        <canvas id="example-canvas" width="500" height="400"></canvas>
                        <div class="controls">
                            <div class="control-group">
                                <label>x:</label>
                                <input type="range" id="x-slider" min="-3" max="3" step="0.1" value="2">
                                <span class="value-display" id="x-value">2.0</span>
                            </div>
                            <div class="control-group">
                                <label>y:</label>
                                <input type="range" id="y-slider" min="-3" max="3" step="0.1" value="1">
                                <span class="value-display" id="y-value">1.0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 3: Scaling Transformation -->
        <div class="slide">
            <div class="bilingual-title">
                <div class="english">Scaling Transformations</div>
                <div class="thai">การแปลงแบบการขยาย</div>
            </div>
            
            <div class="content">
                <div class="formula-showcase">
                    <div class="math-box">
                        $$\text{Scaling Matrix} = \bmat{s_x & 0 \\ 0 & s_y} \quad \text{เมทริกซ์การขยาย} = \bmat{s_x & 0 \\ 0 & s_y}$$
                    </div>
                </div>
                
                <div class="dual-column">
                    <div class="section">
                        <h3>📏 Types of Scaling</h3>
                        <ul>
                            <li><strong>Uniform:</strong> $s_x = s_y$ (same in both directions)</li>
                            <li><strong>Non-uniform:</strong> $s_x \neq s_y$ (different scaling)</li>
                            <li><strong>Enlargement:</strong> $s > 1$ (makes bigger)</li>
                            <li><strong>Reduction:</strong> $0 < s < 1$ (makes smaller)</li>
                            <li><strong>Reflection:</strong> $s < 0$ (flips direction)</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h3>📏 ประเภทของการขยาย</h3>
                        <ul>
                            <li><strong>เท่ากัน:</strong> $s_x = s_y$ (ทั้งสองทิศเท่ากัน)</li>
                            <li><strong>ไม่เท่ากัน:</strong> $s_x \neq s_y$ (การขยายต่างกัน)</li>
                            <li><strong>ขยายใหญ่:</strong> $s > 1$ (ทำให้ใหญ่ขึ้น)</li>
                            <li><strong>ย่อเล็ก:</strong> $0 < s < 1$ (ทำให้เล็กลง)</li>
                            <li><strong>สะท้อน:</strong> $s < 0$ (กลับทิศ)</li>
                        </ul>
                    </div>
                </div>
                
                <div class="interactive-demo">
                    <div class="canvas-container">
                        <canvas id="scale-canvas" width="500" height="400"></canvas>
                        <div class="controls">
                            <div class="control-group">
                                <label>sx:</label>
                                <input type="range" id="sx-slider" min="-3" max="3" step="0.1" value="1.5">
                                <span class="value-display" id="sx-value">1.5</span>
                            </div>
                            <div class="control-group">
                                <label>sy:</label>
                                <input type="range" id="sy-slider" min="-3" max="3" step="0.1" value="2">
                                <span class="value-display" id="sy-value">2.0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 4: Rotation Transformation -->
        <div class="slide">
            <div class="bilingual-title">
                <div class="english">Rotation Transformations</div>
                <div class="thai">การแปลงแบบการหมุน</div>
            </div>
            
            <div class="content">
                <div class="formula-showcase">
                    <div class="math-box">
                        $$\R(\theta) = \bmat{\cos \theta & -\sin \theta \\ \sin \theta & \cos \theta}$$
                        <div style="margin-top: 15px; font-size: 0.9em;">
                            <p><strong>English:</strong> Rotates vectors counterclockwise by angle θ</p>
                            <p><strong>ไทย:</strong> หมุนเวกเตอร์ทวนเข็มนาฬิกาด้วยมุม θ</p>
                        </div>
                    </div>
                </div>
                
                <div class="dual-column">
                    <div class="section">
                        <h3>⚡ Matrix Properties</h3>
                        <ul>
                            <li><strong>Orthogonal:</strong> $\R^T = \R^{-1}$</li>
                            <li><strong>Determinant:</strong> $\det(\R) = 1$</li>
                            <li><strong>Preserves:</strong> distances, angles, areas</li>
                            <li><strong>Origin:</strong> always stays at (0,0)</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h3>⚡ คุณสมบัติของเมทริกซ์</h3>
                        <ul>
                            <li><strong>มุมฉาก:</strong> $\R^T = \R^{-1}$</li>
                            <li><strong>ดีเทอร์มิแนนต์:</strong> $\det(\R) = 1$</li>
                            <li><strong>รักษา:</strong> ระยะทาง, มุม, พื้นที่</li>
                            <li><strong>จุดกำเนิด:</strong> อยู่ที่ (0,0) เสมอ</li>
                        </ul>
                    </div>
                </div>
                
                <div class="interactive-demo">
                    <div class="canvas-container">
                        <canvas id="rotation-canvas" width="500" height="400"></canvas>
                        <div class="controls">
                            <div class="control-group">
                                <label>θ (deg):</label>
                                <input type="range" id="angle-slider" min="0" max="360" step="5" value="45">
                                <span class="value-display" id="angle-value">45°</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 5: Shear Transformation -->
        <div class="slide">
            <div class="bilingual-title">
                <div class="english">Shear Transformations</div>
                <div class="thai">การแปลงแบบการเอียง</div>
            </div>
            
            <div class="content">
                <div class="dual-column">
                    <div class="section">
                        <h3>📐 Horizontal Shear</h3>
                        <div class="math-box">
                            $$\bmat{1 & k \\ 0 & 1}$$
                        </div>
                        <p>Skews along the x-axis</p>
                        <p><em>เอียงตามแกน x</em></p>
                    </div>
                    
                    <div class="section">
                        <h3>📐 Vertical Shear</h3>
                        <div class="math-box">
                            $$\bmat{1 & 0 \\ k & 1}$$
                        </div>
                        <p>Skews along the y-axis</p>
                        <p><em>เอียงตามแกน y</em></p>
                    </div>
                </div>
                
                <div class="interactive-demo">
                    <div class="canvas-container">
                        <canvas id="shear-canvas" width="500" height="400"></canvas>
                        <div class="controls">
                            <div class="control-group">
                                <label>H-Shear:</label>
                                <input type="range" id="hshear-slider" min="-2" max="2" step="0.1" value="0.5">
                                <span class="value-display" id="hshear-value">0.5</span>
                            </div>
                            <div class="control-group">
                                <label>V-Shear:</label>
                                <input type="range" id="vshear-slider" min="-2" max="2" step="0.1" value="0">
                                <span class="value-display" id="vshear-value">0.0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 6: Translation and Euclidean Space -->
        <div class="slide">
            <div class="bilingual-title">
                <div class="english">Translation & Euclidean Space</div>
                <div class="thai">การเลื่อนและปริภูมิแบบยุคลิด</div>
            </div>
            
            <div class="content">
                <div class="dual-column">
                    <div class="section">
                        <h3>❌ The Problem</h3>
                        <p>Standard 2×2 matrices <strong>cannot</strong> perform translation!</p>
                        <div class="math-box">
                            $$\text{Translation: } (x,y) \rightarrow (x+d_x, y+d_y)$$
                        </div>
                        <p>This requires <em>addition</em>, not just multiplication.</p>
                    </div>
                    
                    <div class="section">
                        <h3>❌ ปัญหา</h3>
                        <p>เมทริกซ์ 2×2 ปกติ<strong>ไม่สามารถ</strong>ทำการเลื่อนได้!</p>
                        <div class="math-box">
                            $$\text{การเลื่อน: } (x,y) \rightarrow (x+d_x, y+d_y)$$
                        </div>
                        <p>ต้องใช้<em>การบวก</em> ไม่ใช่แค่การคูณ</p>
                    </div>
                </div>
                
                <div class="formula-showcase">
                    <div class="bilingual-title">
                        <div class="english" style="font-size: 1.6em;">Euclidean Space Properties | คุณสมบัติของปริภูมิยุคลิด</div>
                    </div>
                    
                    <div class="dual-column">
                        <div class="section">
                            <h3>📏 English Properties</h3>
                            <ul>
                                <li><strong>Distance:</strong> Pythagorean theorem</li>
                                <li><strong>Angles:</strong> Dot product formula</li>
                                <li><strong>Parallel lines:</strong> Never meet</li>
                                <li><strong>Fixed origin:</strong> (0,0) cannot move</li>
                            </ul>
                        </div>
                        
                        <div class="section">
                            <h3>📏 คุณสมบัติภาษาไทย</h3>
                            <ul>
                                <li><strong>ระยะทาง:</strong> ทฤษฎีบทพีทาโกรัส</li>
                                <li><strong>มุม:</strong> สูตรดอทโปรดักต์</li>
                                <li><strong>เส้นขนาน:</strong> ไม่มีวันพบกัน</li>
                                <li><strong>จุดกำเนิดคงที่:</strong> (0,0) เลื่อนไม่ได้</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="interactive-demo">
                    <div class="canvas-container">
                        <canvas id="euclidean-canvas" width="500" height="400"></canvas>
                        <div style="text-align: center; margin-top: 15px;">
                            <p><strong>Notice:</strong> All transformations keep origin fixed! | <strong>สังเกต:</strong> การแปลงทั้งหมดคงจุดกำเนิดไว้!</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 7: Affine Space -->
        <div class="slide">
            <div class="bilingual-title">
                <div class="english">Affine Space: Matrix + Translation</div>
                <div class="thai">ปริภูมิแอฟฟีน: เมทริกซ์ + การเลื่อน</div>
            </div>
            
            <div class="content">
                <div class="formula-showcase">
                    <div class="math-box">
                        $$\mathbf{y} = \mathbf{A}\mathbf{x} + \mathbf{b}$$
                        <div style="margin-top: 15px; font-size: 0.9em;">
                            <p><strong>English:</strong> Linear transformation + Translation</p>
                            <p><strong>ไทย:</strong> การแปลงเชิงเส้น + การเลื่อน</p>
                        </div>
                    </div>
                </div>
                
                <div class="dual-column">
                    <div class="section">
                        <h3>🔧 Homogeneous Coordinates</h3>
                        <p>Solution: Add an extra dimension!</p>
                        <div class="math-box">
                            $$\bmat{x' \\ y' \\ 1} = \bmat{a & c & t_x \\ b & d & t_y \\ 0 & 0 & 1} \bmat{x \\ y \\ 1}$$
                        </div>
                        <p>Now ALL transformations are matrix multiplication!</p>
                    </div>
                    
                    <div class="section">
                        <h3>🔧 พิกัดเนื่องเหมือนกัน</h3>
                        <p>วิธีแก้: เพิ่มมิติเข้าไป!</p>
                        <div class="math-box">
                            $$\bmat{x' \\ y' \\ 1} = \bmat{a & c & t_x \\ b & d & t_y \\ 0 & 0 & 1} \bmat{x \\ y \\ 1}$$
                        </div>
                        <p>ตอนนี้การแปลงทั้งหมดคือการคูณเมทริกซ์!</p>
                    </div>
                </div>
                
                <div class="application-grid">
                    <div class="app-card graphics">
                        <h3>🎬 Computer Graphics</h3>
                        <p><strong>English:</strong> 3D model positioning, camera transforms, animation keyframes</p>
                        <p><strong>ไทย:</strong> การวางตำแหน่งโมเดล 3D, การแปลงกล้อง, เฟรมหลักแอนิเมชัน</p>
                    </div>
                    
                    <div class="app-card robotics">
                        <h3>🤖 Robotics</h3>
                        <p><strong>English:</strong> Robot arm kinematics, path planning, sensor calibration</p>
                        <p><strong>ไทย:</strong> จลนศาสตร์แขนหุ่นยนต์, การวางแผนเส้นทาง, การปรับเทียบเซ็นเซอร์</p>
                    </div>
                    
                    <div class="app-card games">
                        <h3>🎮 Game Development</h3>
                        <p><strong>English:</strong> Character animation, physics engines, camera systems</p>
                        <p><strong>ไทย:</strong> แอนิเมชันตัวละคร, เอ็นจินฟิสิกส์, ระบบกล้อง</p>
                    </div>
                    
                    <div class="app-card engineering">
                        <h3>🏗️ Engineering CAD</h3>
                        <p><strong>English:</strong> Mechanical design, stress analysis, manufacturing</p>
                        <p><strong>ไทย:</strong> การออกแบบเครื่องกล, การวิเคราะห์ความเค้น, การผลิต</p>
                    </div>
                </div>
                
                <div class="interactive-demo">
                    <div class="canvas-container">
                        <canvas id="affine-canvas" width="500" height="400"></canvas>
                        <div class="controls">
                            <div class="control-group">
                                <label>tx:</label>
                                <input type="range" id="tx-slider" min="-3" max="3" step="0.1" value="1">
                                <span class="value-display" id="tx-value">1.0</span>
                            </div>
                            <div class="control-group">
                                <label>ty:</label>
                                <input type="range" id="ty-slider" min="-3" max="3" step="0.1" value="1">
                                <span class="value-display" id="ty-value">1.0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 8: Summary -->
        <div class="slide">
            <div class="bilingual-title">
                <div class="english">Summary & Next Steps</div>
                <div class="thai">สรุปและขั้นตอนต่อไป</div>
            </div>
            
            <div class="content">
                <div class="dual-column">
                    <div class="section">
                        <h3>🎯 What We Mastered</h3>
                        <ul>
                            <li><span class="highlight">Matrix as Container</span> - Basis vector transformation</li>
                            <li><span class="highlight">Linear Operations</span> - Rotation, scaling, shearing</li>
                            <li><span class="highlight">Euclidean Limits</span> - Cannot translate origin</li>
                            <li><span class="highlight">Affine Solution</span> - Homogeneous coordinates</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h3>🎯 สิ่งที่เราเชี่ยวชาญ</h3>
                        <ul>
                            <li><span class="highlight">เมทริกซ์เป็นภาชนะ</span> - การแปลงเวกเตอร์พื้นฐาน</li>
                            <li><span class="highlight">การดำเนินการเชิงเส้น</span> - การหมุน, ขยาย, เอียง</li>
                            <li><span class="highlight">ข้อจำกัดยุคลิด</span> - เลื่อนจุดกำเนิดไม่ได้</li>
                            <li><span class="highlight">วิธีแอฟฟีน</span> - พิกัดเนื่องเหมือนกัน</li>
                        </ul>
                    </div>
                </div>
                
                <div class="formula-showcase">
                    <div class="bilingual-title">
                        <div class="english" style="font-size: 1.6em;">The Unified Framework | กรอบงานแบบรวม</div>
                    </div>
                    
                    <div class="math-box">
                        $$\text{Any 2D Transformation} = \bmat{\cos\theta & -\sin\theta & t_x \\ \sin\theta & \cos\theta & t_y \\ 0 & 0 & 1} \bmat{s_x & 0 & 0 \\ 0 & s_y & 0 \\ 0 & 0 & 1} \bmat{x \\ y \\ 1}$$
                    </div>
                    
                    <div class="dual-column">
                        <div class="section">
                            <h3>🚀 Next Learning Goals</h3>
                            <ul>
                                <li><strong>3D Transformations:</strong> Adding the z-dimension</li>
                                <li><strong>Quaternions:</strong> Better rotation representation</li>
                                <li><strong>Eigenvalues:</strong> Understanding matrix behavior</li>
                                <li><strong>Applications:</strong> Build real projects!</li>
                            </ul>
                        </div>
                        
                        <div class="section">
                            <h3>🚀 เป้าหมายการเรียนรูต่อไป</h3>
                            <ul>
                                <li><strong>การแปลง 3D:</strong> เพิ่มมิติ z</li>
                                <li><strong>ควอเทอเนียน:</strong> การแทนการหมุนที่ดีกว่า</li>
                                <li><strong>ค่าลักษณะเฉพาะ:</strong> เข้าใจพฤติกรรมเมทริกซ์</li>
                                <li><strong>การประยุกต์:</strong> สร้างโปรเจกต์จริง!</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="interactive-demo">
                    <div class="bilingual-title">
                        <div class="english" style="font-size: 1.4em;">Final Thought</div>
                        <div class="thai" style="font-size: 1.4em;">ความคิดสุดท้าย</div>
                    </div>
                    
                    <p style="font-size: 1.2em; line-height: 1.6; margin: 20px 0;">
                        <em>"Matrix transformations are the mathematical foundation powering our digital world - from games to self-driving cars."</em>
                    </p>
                    <p style="font-size: 1.2em; line-height: 1.6;">
                        <em>"การแปลงเมทริกซ์คือรากฐานทางคณิตศาสตร์ที่ขับเคลื่อนโลกดิจิทัลของเรา - ตั้งแต่เกมไปจนถึงรถยนต์ที่ขับขี่เอง"</em>
                    </p>
                </div>
            </div>
        </div>
    </div>

    <div class="navigation">
        <button class="nav-button" id="prev-btn" onclick="previousSlide()">← Previous | ก่อนหน้า</button>
        <button class="nav-button" id="next-btn" onclick="nextSlide()">Next | ถัดไป →</button>
    </div>

    <script>
        let currentSlide = 0;
        const totalSlides = 8;
        
        function updateSlidePosition() {
            const container = document.getElementById('slide-container');
            container.style.transform = 'translateX(-' + (currentSlide * 100) + 'vw)';
            
            // Update progress bar
            const progress = ((currentSlide + 1) / totalSlides) * 100;
            document.getElementById('progress-bar').style.width = progress + '%';
            
            // Update counter
            document.getElementById('current-slide').textContent = currentSlide + 1;
            
            // Update navigation buttons
            document.getElementById('prev-btn').disabled = currentSlide === 0;
            document.getElementById('next-btn').disabled = currentSlide === totalSlides - 1;
            
            // Re-render MathJax if available
            setTimeout(function() {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    MathJax.typesetPromise().catch(function(err) {
                        console.log('MathJax error:', err);
                    });
                }
            }, 100);
        }
        
        function nextSlide() {
            if (currentSlide < totalSlides - 1) {
                currentSlide++;
                updateSlidePosition();
            }
        }
        
        function previousSlide() {
            if (currentSlide > 0) {
                currentSlide--;
                updateSlidePosition();
            }
        }
        
        // Drawing functions
        function drawGrid(ctx, width, height, scale) {
            if (scale === undefined) scale = 25;
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Grid lines
            for (let x = centerX % scale; x < width; x += scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            for (let y = centerY % scale; y < height; y += scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
        }
        
        function drawVector(ctx, x, y, centerX, centerY, scale, color, label) {
            if (color === undefined) color = 'blue';
            if (scale === undefined) scale = 25;
            
            const endX = centerX + x * scale;
            const endY = centerY - y * scale;
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 3;
            
            // Vector line
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Arrowhead
            const angle = Math.atan2(endY - centerY, endX - centerX);
            const headLen = 12;
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
            
            // Label
            if (label) {
                ctx.fillStyle = color;
                ctx.font = 'bold 12px Arial';
                ctx.fillText(label, endX + 10, endY - 10);
            }
        }
        
        function initBasisVisualization() {
            const canvas = document.getElementById('basis-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid(ctx, canvas.width, canvas.height);
                
                const a = parseFloat(document.getElementById('a-slider').value);
                const b = parseFloat(document.getElementById('b-slider').value);
                const c = parseFloat(document.getElementById('c-slider').value);
                const d = parseFloat(document.getElementById('d-slider').value);
                
                // Update value displays
                document.getElementById('a-value').textContent = a.toFixed(1);
                document.getElementById('b-value').textContent = b.toFixed(1);
                document.getElementById('c-value').textContent = c.toFixed(1);
                document.getElementById('d-value').textContent = d.toFixed(1);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = 30;
                
                // Original basis vectors (gray)
                drawVector(ctx, 1, 0, centerX, centerY, scale, '#aaa', 'i');
                drawVector(ctx, 0, 1, centerX, centerY, scale, '#aaa', 'j');
                
                // Transformed basis vectors
                drawVector(ctx, a, b, centerX, centerY, scale, '#e74c3c', 'col1');
                drawVector(ctx, c, d, centerX, centerY, scale, '#3498db', 'col2');
            }
            
            ['a-slider', 'b-slider', 'c-slider', 'd-slider'].forEach(function(id) {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', draw);
                }
            });
            
            draw();
        }
        
        function initExampleVisualization() {
            const canvas = document.getElementById('example-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid(ctx, canvas.width, canvas.height);
                
                const x = parseFloat(document.getElementById('x-slider').value);
                const y = parseFloat(document.getElementById('y-slider').value);
                
                // Update value displays
                document.getElementById('x-value').textContent = x.toFixed(1);
                document.getElementById('y-value').textContent = y.toFixed(1);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = 30;
                
                // Matrix A = [3 1; 0 2]
                const resultX = 3 * x + 1 * y;
                const resultY = 0 * x + 2 * y;
                
                // Matrix columns
                drawVector(ctx, 3, 0, centerX, centerY, scale, '#aaa', '[3,0]');
                drawVector(ctx, 1, 2, centerX, centerY, scale, '#aaa', '[1,2]');
                
                // Original vector
                drawVector(ctx, x, y, centerX, centerY, scale, '#2ecc71', 'input');
                
                // Transformed vector
                drawVector(ctx, resultX, resultY, centerX, centerY, scale, '#e74c3c', 'result');
            }
            
            ['x-slider', 'y-slider'].forEach(function(id) {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', draw);
                }
            });
            
            draw();
        }
        
        function initScaleVisualization() {
            const canvas = document.getElementById('scale-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid(ctx, canvas.width, canvas.height);
                
                const sx = parseFloat(document.getElementById('sx-slider').value);
                const sy = parseFloat(document.getElementById('sy-slider').value);
                
                // Update value displays
                document.getElementById('sx-value').textContent = sx.toFixed(1);
                document.getElementById('sy-value').textContent = sy.toFixed(1);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = 30;
                
                // Original unit square
                ctx.strokeStyle = '#aaa';
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX, centerY - scale, scale, scale);
                
                // Scaled square
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.strokeRect(centerX, centerY - sy * scale, sx * scale, sy * scale);
                
                // Basis vectors
                drawVector(ctx, sx, 0, centerX, centerY, scale, '#e74c3c');
                drawVector(ctx, 0, sy, centerX, centerY, scale, '#3498db');
            }
            
            ['sx-slider', 'sy-slider'].forEach(function(id) {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', draw);
                }
            });
            
            draw();
        }
        
        function initRotationVisualization() {
            const canvas = document.getElementById('rotation-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            function draw() {
                const angle = parseFloat(document.getElementById('angle-slider').value);
                document.getElementById('angle-value').textContent = angle + '°';
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid(ctx, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = 40;
                
                const rad = (angle * Math.PI) / 180;
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);
                
                // Original basis vectors
                drawVector(ctx, 1, 0, centerX, centerY, scale, '#aaa', 'i');
                drawVector(ctx, 0, 1, centerX, centerY, scale, '#aaa', 'j');
                
                // Rotated basis vectors
                drawVector(ctx, cos, sin, centerX, centerY, scale, '#e74c3c', 'i\'');
                drawVector(ctx, -sin, cos, centerX, centerY, scale, '#3498db', 'j\'');
            }
            
            const angleSlider = document.getElementById('angle-slider');
            if (angleSlider) {
                angleSlider.addEventListener('input', draw);
            }
            
            draw();
        }
        
        function initShearVisualization() {
            const canvas = document.getElementById('shear-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid(ctx, canvas.width, canvas.height);
                
                const hshear = parseFloat(document.getElementById('hshear-slider').value);
                const vshear = parseFloat(document.getElementById('vshear-slider').value);
                
                // Update value displays
                document.getElementById('hshear-value').textContent = hshear.toFixed(1);
                document.getElementById('vshear-value').textContent = vshear.toFixed(1);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = 40;
                
                const vertices = [[0,0], [1,0], [1,1], [0,1]];
                
                // Original square
                ctx.strokeStyle = '#aaa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < vertices.length; i++) {
                    const x = vertices[i][0];
                    const y = vertices[i][1];
                    const screenX = centerX + x * scale;
                    const screenY = centerY - y * scale;
                    if (i === 0) ctx.moveTo(screenX, screenY);
                    else ctx.lineTo(screenX, screenY);
                }
                ctx.closePath();
                ctx.stroke();
                
                // Sheared square
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let i = 0; i < vertices.length; i++) {
                    const x = vertices[i][0];
                    const y = vertices[i][1];
                    const newX = (1 + vshear) * x + hshear * y;
                    const newY = vshear * x + (1) * y;
                    const screenX = centerX + newX * scale;
                    const screenY = centerY - newY * scale;
                    if (i === 0) ctx.moveTo(screenX, screenY);
                    else ctx.lineTo(screenX, screenY);
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            ['hshear-slider', 'vshear-slider'].forEach(function(id) {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', draw);
                }
            });
            
            draw();
        }
        
        function initEuclideanVisualization() {
            const canvas = document.getElementById('euclidean-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid(ctx, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 40;
            
            // Show that matrix transformation keeps origin fixed
            const vertices = [[1,0], [1,1], [0,1]];
            
            // Original triangle
            ctx.strokeStyle = '#aaa';
            ctx.fillStyle = 'rgba(170,170,170,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            for (let i = 0; i < vertices.length; i++) {
                const x = vertices[i][0];
                const y = vertices[i][1];
                ctx.lineTo(centerX + x * scale, centerY - y * scale);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Transformed triangle (rotation example)
            ctx.strokeStyle = '#e74c3c';
            ctx.fillStyle = 'rgba(231,76,60,0.3)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            for (let i = 0; i < vertices.length; i++) {
                const x = vertices[i][0];
                const y = vertices[i][1];
                const newX = x * 0.7 - y * 0.7;
                const newY = x * 0.7 + y * 0.7;
                ctx.lineTo(centerX + newX * scale, centerY - newY * scale);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Highlight fixed origin
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        function initAffineVisualization() {
            const canvas = document.getElementById('affine-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid(ctx, canvas.width, canvas.height);
                
                const tx = parseFloat(document.getElementById('tx-slider').value);
                const ty = parseFloat(document.getElementById('ty-slider').value);
                
                // Update value displays
                document.getElementById('tx-value').textContent = tx.toFixed(1);
                document.getElementById('ty-value').textContent = ty.toFixed(1);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = 40;
                
                const vertices = [[1,0], [1,1], [0,1]];
                
                // Original triangle
                ctx.strokeStyle = '#aaa';
                ctx.fillStyle = 'rgba(170,170,170,0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                for (let i = 0; i < vertices.length; i++) {
                    const x = vertices[i][0];
                    const y = vertices[i][1];
                    ctx.lineTo(centerX + x * scale, centerY - y * scale);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Affine transformed triangle (rotation + translation)
                ctx.strokeStyle = '#e74c3c';
                ctx.fillStyle = 'rgba(231,76,60,0.3)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                // Apply transformation y = Ax + b - starting with origin
                const startX = 0 * 0.7 - 0 * 0.7 + tx;
                const startY = 0 * 0.7 + 0 * 0.7 + ty;
                ctx.moveTo(centerX + startX * scale, centerY - startY * scale);
                
                for (let i = 0; i < vertices.length; i++) {
                    const x = vertices[i][0];
                    const y = vertices[i][1];
                    const newX = x * 0.7 - y * 0.7 + tx;
                    const newY = x * 0.7 + y * 0.7 + ty;
                    ctx.lineTo(centerX + newX * scale, centerY - newY * scale);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Show translation vector
                drawVector(ctx, tx, ty, centerX, centerY, scale, '#2ecc71', 't');
            }
            
            ['tx-slider', 'ty-slider'].forEach(function(id) {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', draw);
                }
            });
            
            draw();
        }
        
        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowLeft') previousSlide();
            if (e.key === 'ArrowRight') nextSlide();
        });
        
        // Initialize everything
        window.addEventListener('load', function() {
            updateSlidePosition();
            
            setTimeout(function() {
                initBasisVisualization();
                initExampleVisualization();
                initScaleVisualization();
                initRotationVisualization();
                initShearVisualization();
                initEuclideanVisualization();
                initAffineVisualization();
                
                // Initial MathJax render
                if (window.MathJax && window.MathJax.typesetPromise) {
                    MathJax.typesetPromise().then(function() {
                        console.log('MathJax initialized');
                    });
                }
            }, 200);
        });
    </script>
</body>
</html>